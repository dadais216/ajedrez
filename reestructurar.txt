
Hay que hacer que los movimientos se guarden en memoria para evitar recalcularlos constantemente

La IA evalua el tablero por cada movimiento, y evaluar el tablero implica calcular todos los movimientos.
Si los movimientos se guardan en memoria solo va a ser necesario recalcular los movimientos de la pieza que se movio
y las que sean afectadas por eso
(si n es la cantidad de movimientos y extra los movimientos de piezas afectadas la cantidad de calculos en el primer turno
es 2n+extra, y en el proximo es n+extra. Sin guardan en memoria la cantidad de calculos es n^2 en todos los turnos)

Tambien se ahorrarían recalculos para ver si hay jaque

--

El lenguaje da las instrucciones para formar movimientos
Hay 3 estructuras de movimiento, normal, desliz y opt.

los movimientos tienen en comun:
bool estado, valido o invalido
lista pos triggers, si una de estas posiciones se pisa o se deja por la pieza que se esta movimiendo se tiene que recalcular
(debería haber varios tipos de triggers, de chequeo de vacio, enemigo, etc? por ahi no, nomas serían utiles es casos raros
y aun asi no cubririan todos los casos)
lista acciones, con las acciones marcadas en posiciones absolutas
next, para encadenar movimientos
tambien podrían tener un enum que los identifique, para hacer algunas optimizaciones especificas (si hay)

en un movimiento normal:
cuando se activa un trigger, siendo el estado valido o invalido, se recalcula.
En la gran mayoria de los casos si el estado es valido se vuelve invalido, aun asi habría que recalcular por casos raros

desliz:
contiene una lista de movimientos, que genera a partir de un movimiento interno
su estado es valido si el primer movimiento es valido, en la lista de movimientos todos menos el ultimo son validos
cuando falla un trigger se invalidan todos los siguientes movimientos en la lista y se recalcula el fallado, reconstruyendo
si hay un next se corre cuando falle el ultimo

desliz genera los movimientos conforme los chequeos de su movimiento interno sigan dando verdadero, por lo que va ocupando
memoria con movimientos absolutos. Cuando fallan se borran. 
Por ahi podría no borrarse y mantener la memoria reservada, habría que ver. (si termina siendo necesario)


la ventaja de hacer desliz una estructura es que una cadena de movimientos se guarda como una cadena de movimientos, no
una lista de movimientos donde cada elemento tiene una copia del anterior mas un paso mas
y tambien da lugar a un manejo mas inteligente de los recalculos, ya no es necesario recalcular toda la cadena, solo
lo que venga despues de un trigger
para recalcular avanzado habría que guardar la pos de cada inicio de mov o algo asi, no debería ser complicado


desliz se tiene como siguiente a si mismo para manejarse bien con las ramificaciones de opt, si usara un bucle while habría
que crear una estructura de control para cada ramificacion de opt

opt:
contiene una lista de movimientos internos que usa para crear ramificaciones, tambien una lista de acciones y triggers para
cada rama.
Se limita a recalcular solo la rama que haya disparado un trigger.

--


los movimientos se guardan en memoria como una accion y una pos. Ocupa mas espacio y hay muchas posiciones repetidas,
pero hay que calcular menos cuando se hacen los calculos de movimientos y eso es lo que necesita mas velocidad.
Se van a tener que copiar mas posiciones pero no se van a tener que copiar las instrucciones que cambiaban la posicion.
A demas la posicion global tarda mas en acceder, debe ser eso lo que realentiza
Y es algo que se abstrae del lenguaje.

se manejan desde controladores de normal, desliz y opt

dentro de normal:
las condiciones si son falsas invalidan el movimiento y dejar un trigger en esa pos. Hasta que no se dispare ese trigger
ese mov queda invalidado.
si es verdadero se dejan triggers y se sigue mirando hasta terminar. 

No sé si opt exc se va a poder agregar sin muchos problemas, en cualquier caso hacer un operador exc o if que haga eso y listo




Actualmente cuando se toca una pieza a partir de las instrucciones se generan clickers, que crean una copia
de el buffer de acciones y de colores. No hay distincion entre desliz, opt y normal a este nivel, los clickers
se crean de forma explicita

el sistema nuevo tendría que crearlos usando las estructuras que tambien usa la IA, asi queda todo con lo mismo y no
hay un quilombo de cosas. A demas el sistema anterior tenia cosas raras, ver si se puede hacer algo con para que no
pasen en este


Una vez hecha la generacion va a quedar una lista de movimientos con posiciones absolutas dentro de 
las estructuras (normal, desliz, opt).

No sé si hay una forma clara de delimitar movimientos, puede que necesite poner una especie de click.
Por ahi se puede hacer solo usando unos flags y aprovechando que las estructuras ahora son diferenciables.
-al llegar a una normal sin continuacion
-en cada elemento de la lista de un desliz nc
-aplicando las mismas reglas en cada rama de un opt
y arrastrando todo lo que haya atras

la forma de identificar estos movimientos en las estructuras debería ser rapida, iterable y referenciable.
La IA va a necesitar obtener un elemento, hacer algunas acciones, y luego obtener el proximo. 
Los clickers van a necesitar alguna forma de referenciar que elemento de la lista de movimientos, y de que a que punto,
hace referencia
Hay que tener en cuenta que los movimientos se van a leer muchas veces

Supongo que lo mejor va a ser tener una funcion que devuelva
un movimiento en forma de lista de normales. La proxima vez que se la llame va a dar otro.
Va a usar una estructura interna para saber cual es el siguiente o terminar
Tambien se puede guardar y restaurar
esta lista de normales es lo que se guarda en los clickers. La lista es de punteros para que sea rapido y simple

Un tema es que la IA va a tener que usar esa funcion muchas veces para acceder a los mismos movimientos.
(en cada iteracion del analisis de tableros. Abstraer el movimiento asi es util porque los recalculos no afectan nada)
Aunque la funcion debería ser bastante rapida y no debería dar problemas.
Guardar las normales en memoria y cambiarlas en caso de recalculo es una opcion, pero puede que mantener las listas
en memoria y hacer chequeos de reemplazo y reemplazos a demas de ser complejo termine siendo mas lento. 
La funcion solo debería hacer unas comparaciones de ints antes de devolver una lista de normales.

La funcion recibe un vector<normalHolder*>* para evitar tener que armar la lista y despues copiarla a el clicker o la
estructura de control de la normal. Si la funcion no puede generar nada devuelve falso y listo, si puede genera, lo tira
en ese puntero y eso se pasa al constructor de clicker



limites y memoria
estos funcionan durante el chequeo de condiciones, esta parte esta bastante intacta, no debería haber problemas
Como en el producto final solo quedan las acciones no debería haber uso de memoria en el resultado final, es un condt
la memoria era movt por posrestore y posremember nomas. Estos se pueden implementar como actt que tienen la pos seteada
en la fase de condiciones
en desliz y deslizopt se va a tener que guardar el estado de memoria para retomar calculos, pero solo ahi

bloque
bloque<contenido> = opt<contenido TERMINAR,>
podría hacerse como un opt agregando un comando de terminar forzazamente el movimiento, o como una estructura unica.
Hacer una estructura unica es gratis y es mas limpio
Usaría un solo int de control, 0 hace que devuelva su normal y termine el movimiento, 1 hace que no haga nada

De la misma forma podría agregarse un exc asi no bloteo opt




Lo primero a implementar es sacar las instrucciones de movimiento, y poner la pos directamente en las acciones.
En terminos de memoria es mas o menos lo mismo porque cada movimiento implica un puntero mas, se ahorran espacio
si hay muchas acciones en una posicion pero se pierden si hay muchos movimientos.
Y tener posiciones relativas va a ser mas facil conseguir absolutas, y las absolutas hacen todo el proceso mas simple y
rapido
Dentro de una normal las posiciones relativas son fijas
Supongo que los graficos van a estar ligados a la normal, aparte de las acciones para ser toggeables. Se van a manejar igual,
con posiciones absolutas y eso. En el sistema nuevo va a haber muchas menos copias al pedo de un mismo sprite, y usando
indireccion se podría hacer que sean re pocas, una por RGBA usado, no se si es al pedo igual

no hay necesidad de acm porque las pos van a estar en cada cosa

De paso desglobalizar todo para no tener problemas de thredeado

lo unico malo de thredear es que tengo que pasar por parametro la pos, el holder y el tablero del thread. Pero bueno, no
creo que traiga mucho problema
Supongo que lo mejor para esto va a ser meter la pos y el tablero dentro de holder y pasar solo holder. Total el tablero
se accede pocas veces y aunque la pos se accede muchas veces es mas rapido acceder a ella que copiarla, supongo
variables como outbounds se van a tener que guardar en holder
los movimientos absolutos y triggers tambien, dentro de las estructuras de normal y eso

la ventaja de tener el tablero como una matriz de punteros es que preguntar si una pieza esta en una posicion es directamente
mirar en la matriz, en lugar de recorrer un vector de piezas comparando numeros
Por otro lado, tener la pos guardada en el holder seria un poco mas comodo porque se tendría que pasar un parametro menos
en las llamadas a funcion, aunque en la mayoria de los casos despues se va a tener que obtener la pos de ese puntero. Aun asi,
puede que sea mas rapido. La pos se determina antes de llamar a calcular movimientos segun la matriz, y se suma a los valores
relativos de cada movimiento.

el desliz despues de cada iteracion setea pos a la pos del ultimo movimiento de su lista



cuando se intente calcular los movs de un holder, en un primer turno:
se calculan todos los movimientos, lo que implica obtener todos los movimientos de pieza, que ya tienen las posiciones
relativas armadas, transformar las condiciones a absolutas y probar que anden.
si andan, traducir las posiciones de las acciones y guardarlas (por ahora alocando y borrando, despues intentar no borrar)
(se guardan en el holder, es algo unico de este)
Las condiciones tambien guardan una lista de posiciones que se usa de trigger (no me parece util diferenciar entre distintos
tipos de triggers), conforme se vayan evaluando, cortando antes si es falso
En los proximos turnos se recalculan movimientos solo si se pisan triggers


En holder van a estar los movimientos absolutos y los triggers, dentro de estructuras de control
En pieza van a estar los movimientos relativos y las condiciones

En cada turno se recorren todos los holder para ver si alguna estructura de control activo un trigger. De hacerlo,
la misma va a llamar a la parte correspondiente en pieza para recalcular
Por lo que cada estructura de control va a necesitar un puntero a su estructura correspondiente en pieza, y tambien 
pasarse a si mismo como parametro. Quedo medio raro
Supongo que basta con un puntero a funcion, sino un puntero a objeto

si se activa un trigger en normal llama a normal en pieza y este recalcula, pasa todas las condiciones y acciones
las normales solo se generan a traves de deslices, por lo que estos deberían ser los encargados de armarlas, ademas
del arme inicial. Asi evito tener ifs de generado adentro de las normales y se aceleran un poco las cosas

tengo que ver como copiar los accs de pieza a holder


Desliz manda a revisar triggers a su contenido. Si alguno se activa, manda a recalcular a este y a los siguientes
Por ejemplo, si tiene normal la primera normal que se active y las siguientes llamarian a pieza
si tiene desliz, este desliz haria lo mismo con sus normales y si hubo recalculos le avisa a desliz, y todas las proximas
iteraciones se recalculan
la pos a adelantar se obtiene de el ultimo elemento de la ultima normal.
No sé si va a haber problemas con opts, verlo cuando esten mas pensados
Como voy a hacer opt distinto hacer que desliz no se llame a si mismo ocupando el stack al pedo


Desliz crea una nueva instancia de contenido en holder, de necesitar, antes de llamarla a calcular, y pieza la setea.
Asi se ahorra tener que crear y destruir al pedo

Opt como esta ahora no sirve porque genera los datos al aire. Cuando esta adentro de un desliz genera una estructura
de arbol y desliz genera listas. No hay forma de meter el arbol en la lista, al menos no una forma simple que se haga
desde adentro de un opt no conciente de que esta en un desliz. Y aunque hubiera una solucion tendría que tener en cuenta
todos los casos raros de anidacion y demases
-
Una solucion desde adentro de opt es hacer que cada vez que se lo llame genere sus 2 entradas (suponiendo que tenga 2 ramas),
la proxima vez 2^2 y asi, estableciendo una relacion numerica entre cada uno. (el de la pos N le siguen 2N y 2N+1).
El tema de esto es que opt necesita saber cuantas veces se lo llamo, y cosas como recalcular son complicadas. Tampoco estoy
seguro de que funcione con casos raros, y la estructura termina siendo medio bizarra
-
otra solucion es crear una estructura deslizopt que se arme en una segunda barrida, haciendo algo como
desliz n1 opt n2 , n3 end n4 end => deslizopt(n1,(n2,n3),n4)
Sería lo mejor porque se llevaria bien con cualquier tipo de anidacion rara, y maneja los casos de tener cosas 
antes y despues de opt de la forma mas eficiente. Crea la estructura de arbol directamente sin tener que hacer cosas
rebuscadas. Es lo mas limpio.
Igual dejar esto para mas adelante, ahora no es algo necesario.
Tambien esta el tema de tener desliz opt n1 n2 end n3 opt n4 n5 end end, cosas como esta podrían directamente prohibirse
porque nomas se dan en casos muy raros y pueden reescribirse de forma que no creen problemas y se mantengan igual











porRestore se deberían sacar porque no siguen en esquema de que cada normal tiene posiciones relativas fijas
(lo que no es una restriccion necesaria pero las demas cosas la cumplen y simplifica un poco),
por ejemplo w posRestore w no se podría pasar a relativas fijas. A ori, si actua solo dentro de una normal, no le 
veo mucho sentido.
posRestore no se usaria casi nunca pero tener algo que cargue posiciones a memoria permite hacer las piezas que
promocionan en tal lugar sin usar contadores. Tambien se podría replicar un posRestore haciendo un desliz de normales que
cuenten y avancen.


Carga de movimientos:
Al iniciar la partida se cargan todos los movimientos de todas las piezas.

Si el turno es de un humano, al elegir una pieza, con sus movimientos ya cargados, por cada movimiento se cargan todos
los cambios de tablero que forme, que es volver a generar los movimientos de esa pieza en su nueva posicion y los movimientos 
que se hayan recalculado por pisar triggers. Esto se hace para evitar movimientos invalidos que tengan que ver con el jaque
y para marcar jaques

Si el turno es de la IA, esta genera todos los cambios por cada movimiento que tiene y hace sus cosas











Habría un beneficio en guardar todos los movimientos de movimientos? Como con los movimientos, habría una un incremento
importante en la memoria que se usa, pero las cosas se harían mas rapido a la larga. La IA no tendría que recalcular los
cambios que causa un movimiento si estos cambios no activaron sus triggers
Al inicio de la partida se calcularian todos los movimientos y los cambios de cada uno (los movimientos de esa pieza
una vez que cambio de posicion y los recalculos de los movimientos que se haya triggereado).
En el turno del jugador todas las piezas tienen sus movimientos cargados, las que se invalidan por jaque estan invalidadas
y las que crean jaques estan marcadas. No hay que calcular nada.
En el turno de la IA tampoco hay que calcular nada, habría que correr la funcion de puntuar tablero con la informacion
existente.

Despues de que se efectue un movimiento habría que reemplazar los calculos del movimiento central, que es el que acaba
de hacerse, por el de segundo orden que corresponda. Borrar los demas movimientos de segundo orden y calcular nuevos.
Esto es lo unico que se calcularia en cada turno

La diferencia entre este sistema y el que habia pensado antes es que este guarda los cambios y el anterior no, el anterior
recalcula cosas al pedo y este ocupa mas memoria. Como hasta ahora estuve yendo por el camino de ocupar mas memoria voy
a seguir con eso.

se calculan todos los movimientos de todas las piezas, con sus triggers. 
por cada movimiento se calculan los movimientos de segundo orden, como se tiene que pasar por condiciones ya se cargan
sus triggers pero no se usan para nada por el momento. Una vez calculado cada movimiento de segundo orden se mira si
piso algun trigger de primer orden de toda la lista y en caso de haberlo hecho se guarda en ese movimiento el recalculo 
del pisado (la IA haria esto en cada turno sino)

los recalculos nunca causan mas recalculos, creo. Pasaría con piezas tardias, pero estas van a tener su sistema y no
creo que rompan nada

Aleatorio no necesita este sistema pero se lo dejo, no vale la pena meter un if para esto total es algo que no se va
a usar nunca. Quedaría para debuggear velocidades

Se hace en forma general en lugar de desde la IA porque asi puedo guardar cosas directamente en los movimientos sin que
quede raro y tambien porque el jugador humano necesita el segundo orden para hacer el chequeo de jaques






La IA como esta ahora no valora las piezas, nomas valora como esta el tablero antes y despues de hacer un movimiento.
Ver si esto es suficiente

Optimizacion:
cuando falla un trigger de una normal no es necesario verificar todas las condiciones, solo la que generó ese trigger.
El tema es que los triggers no se diferencian y no hacen referencia a sus condiciones, y si lo hacen terminario siendo
todo mas lento
Pero puede que se pueda relacionar un trigger con su condicion por la posicion en la que esta en la lista. El trigger #3
debería corresponder a la condicion #3 de la normal. Seguro que esto varia un poco ya que no todas las condiciones
generan triggers, pero aun asi puede hacerse algo


--

Piezas como el ubi ubi no van a llevarse bien con la IA porque tienen una cantidad de movimientos muy grande que se va
a elevar al cuadrado. Podría meterse un ubi ubi haciendo que sus movimientos solo terminen con una pieza capturada, y 
metiendo un prob persistente en cada pieza que se capture. El deslizopt se va a gastar y solo van a quedar tantos movimientos
como piezas en rango del ubi ubi, que va a ser un numero bajo

El emperado puede meterse directamente, va a tardar en cargar al principio pero sus calculos solo van a variar por
cada movimiento de pieza, y no de forma exagerada

Creo que no hay ninguna condicion no posicional que importe. Se podría dar que una pieza base su condicion en una propiedad
de otra y cosas como every cambien esa propiedad. En estos casos especificos se podría hacer que un cambio en una pieza
active los triggers que esten sobre esa pieza


estaria bueno llegar a un nivel de abstraccion donde el jaque puede
armarse desde el lenguaje.
El rey tendría un every que prohibe movimientos aliados que lo dejen
amenazado.
Lo unico que habría que hacer es darle a every la capacidad de invalidar
el movimiento anterior, el resto debería venir solo con el segundo orden


actualmente los triggers estan en vectores en cada movimiento de cada
pieza. Cuando se hace un movimiento se genera un vector de pisados, si
alguna coordenada de ese vector coincide con alguna coordenada de un trigger
se recalcula el movimiento del trigger
La IA tiene que hacer este proceso de contraste de vectores por cada movimiento,
por lo que puede terminar siendo lento. Aun asi es mas rapido que recalcular
todos los movimientos
Otra forma de hacerlo sería por señales. En cada pos se deja un struct, que
simboliza el trigger. Este struct contiene un puntero al movimiento de la
pieza que lo causo. A su vez la pieza tiene un puntero al struct. 
Entonces, cuando se genera el vector de pisados nomas hay que mirar en esos
pisados. Si hay triggers se activan.
Por otro lado, cada vez que una pieza se actualiza (por ahora solo moviendose,
pero tambien esta el caso de que cambie) se tienen que sacar sus triggers y
poner otros. Supongo que todo se hace usando mapas en el tablero
No sé si va a terminar siendo mas eficiente, y es mas complejo. A la larga
puede que lo sea. Igual por ahora mantenerlo como esta, si mas adelante
veo que lo necesito lo meto.
Como segundo orden va a usar un sistema parecido podría meterlo ahora


segundo orden
La IA necesita crear todos los tableros posibles dentro de un turno, por
lo que necesita calcular todos los movimientos despues de cada movimiento.
Se ahorran muchos calculos guardando los movimientos basicos en memoria,
por lo que lo unico que se necesita recalcular por movimiento son los movimientos de la pieza que se movio y lo que haya levantado triggers.

Se podría calcular esto al aire y listo, aunque sería util guardar los
movimientos de segundo orden tambien para no tener que recalcularlos si se
necesitan.
Comparando:
si se calcula al aire, una pieza quieta tendría que recalcular sus movimientos de segundo orden cada turno. 
Si se guarda en memoria, solo debería recalcular cuando se levante un trigger
de segundo orden. 

Los triggers de segundo orden se guardan en los movimientos de primer orden. Cuando se activan se recalcula directamente. Es mucho mas rapido que recalcular todos los movimientos todos los turnos, con el costo de meter un trigger hell.

Hay que tener en cuenta que el segundo orden solo va a ser usado por la IA y algunas piezas especiales (como el rey), si ninguna de las dos esta presente entonces no se arma. Nada simple debería depender de que exista. Tambien, como la carga de movimientos tiene dos fuentes hay que mirar que lo que se necesite calcular no haya sido calculado por la otra
Thredear no debería ser demasiado complejo, cada thread maneja el recalculo de 
movimientos distintos en tableros distintos. El tablero original se tiene en comun, pero solo se lee. Los cambios de segundo orden son unicos de cada movimiento de primer orden, y se guardan en estos, no hay conflicto.





aclaracion sobre every:
Dependiendo como este configurado, un every puede correr al finalizar el turno de un jugador, o en cada turno de los dos jugadores. 
Para que las cosas anden bien el segundo orden tiene que tener en cuenta que los efectos de every pueden pasar antes y despues de los movimientos enemigos (no hace explosion combinatronica porque no hay ramificaciones, es solo cosas que se procesan antes y despues de cada movimiento)


!mirar el tema del copyrigth con las fuentes

Hacer el juego para mas de 2 jugadores es hacible, pero no vale la pena.
Bando dejaria de ser un bool, los colores de las piezas deberían determinarse con una funcion y ser un efecto arriba del sprite, se necesitaria agregar un prefijo al tablero de texto. 
Internet se complicaria un poco pero no demasiado. 
El problema esta en la IA. Para actuar bien tendría que no solo calcular el movimiento del proximo jugador, sino de toda la cadena de jugadores. Y eso hace una explosion combinatronica.
Tambien esta el tema de que no entendería muy bien alianzas ni cosas por el estilo.
Se podría agregar el modo de mas de 2 jugadores para solo humanos, pero es mucho trabajo por algo que no creo que se use mucho. A demas, muchos juegos de mas de dos personas usan tableros no cuadrados, y eso es algo que no pienso agregar.



%%% memoria
Hay 4 memorias: movimiento, pieza, tile y global

La de movimiento se entiende como local, las otras 3 globales.

La local se guarda en cada normalHolder para poder restaurarla cuando se recalcula. 

Las operaciones de lectura se hacen durante el chequeo de condiciones, mientras que las de escritura se hacen solo si es sobre memoria local. 
Las escrituras sobre memoria global son acciones

Hay casos raros donde es util escribir espacio global durante el chequeo de condiciones, asi que se va a agregar una notacion especial para eso. Aunque es algo raro de pensar porque los chequeos pueden pasar en momentos inesperados, asi que se tiene que usar sabiendo que se esta haciendo


mcpm
mset
madd

reciben dos numeros, cada uno con un identificador de donde vienen

l - local
p - pieza
t - tile
g - global

se puede acceder a la posicion actual del puntero / numero de turno poniendo px,py,t
(una forma garca de implementar esto seria reemplazandolos por g-1,g-2,g-3, pero eso requeriria actualizar ese espacio de memoria para cada cambio de posicion)






mgrw - toma un valor. Si ese valor es mas grande que la memoria, la agranda
Con esto se pueden tener memorias de tamaño variable sin tener que especificar nada
Lo malo es que si se lee antes de escribir se rompe todo pero es esperable, aclarar en el instructivo. No creo que cuelgue el juego 
Manejarse con un comando aparte hace que no se haga este chequeo en la escritura normal, y en la version compilada permite usar arrays en vez de vectores cuando se vea que no esta

cuando se hace el chequeo de condiciones, dentro de una normal, el orden de procesado de condiciones es lecturas -> condiciones que no usan memorias -> escrituras.

Esto es para manejar eficientemente casos como
w mcmp 0l 0 mover 
w vacio mset 0l 1

pero hace cosas como
madd 1l 1 mcmp 1l 3
raras porque el mcmp se ejecuta antes del madd.

Podría hacer que todo se ejecute en orden, pero tendria que meter un chequeo por iteracion y agregar otro nivel de polimorfismo. Por ahora lo dejo asi. 

O no. termina siendo muy no intuitivo, y no creo que atrase demasiado. Ir por la otra, que termina comportandose como se comporta la version final. 


--

Algo ahora imposible en el lenguaje es poder armar una lista de tamaño indefinido, y poder recorrerla. Esto es util en bastantes piezas y es algo que debería estar.
Lo que se necesita especificamente es que un valor indique en que posicion de memoria ejectar un comando (hasta ahora los comandos toman una posicion constante, como l0, y no se puede pasar algo variable como lX)

Una forma de hacerlo es harcodeando algunos operadores, pero haria el lenguaje feo y no se podría acceder a los operadores comunes, a menos que se haga una version especial de cada uno de estos y haya un sistema que los relacione y que se yo. No

Una opcion es algo como
mdir d0 l0 desliz mshift d0 1 mdist d0 l8 mset d0 0 end #limpiar una lista de 8

habria que agregar 3 operadores y un tipo de memoria (global), d, que sería como un puntero. Este puntero puede apuntar a cualquier tipo de memoria, y se determina a que apunta como mdir. mshift la desplaza, y mdist retorna true si donde apunta es distinto a su segundo parametro. 
mdir va a tener que usar polimorfismo para saber como desplazarse. (o al menos va a tener 2 versiones, una global y una local, por la forma en que esta armada la memoria).
Puede que tenga otros problemas con los tipos y demas que no estoy pensando ahora. 
Puede que sea un poco confuso porque mete la idea de punteros, pero bueno. No es una mala opcion.

Otra opcion es algo como
desliz mset ll0 0 madd l0 1 mless l0 9 end mset l0 0 #limpiar lista de 8

Este me gusta mas porque es mas intuitivo y no agrega comandos nuevos. Es mas explicito tambien, se lee mejor. 
Para implementarlo habria que dar la posibilidad de que los accesores puedan tomar accesores en vez de constantes, lo que probablemente se implemente dandoles una nueva version.
--
Esto se podría hacer con templates, pero ya es un quilombo y da pie a cambiar todo por polimorfismo. Total esta no es la version final y la diferencia de velocidad no va a ser muy notable. Y puede que el tiempo de compilacion se haga muy largo con templates, a demas de que va a ser un asco escribir eso
--

Un criterio importante para definir cual usar va a ser cual es mas rapido en la version final, compilada.
El primero tomaría un puntero a un lugar y lo desplazaria. 
El segundo accede pasando una variable a un array. 
Si es un acceso solo son iguales, y creo que despues tambien. Los dos hacen una suma y un acceso, el primero incrementando el puntero y accediendo, el segundo incrementando la base del array por la variable y accediendo. Puede que el primero sea marginalmente mas rapido porque toma una constante en lugar de una variable, pero son practicamente lo mismo.

Me parece que voy a ir por el segundo porque es mas facil de escribir. En el producto final van a ser casi igual de rapidos, asi que no estoy perdiendo nada



---

mcmp p0 2
mset p0 2
mcmp p0 p1
mset p0 p1
mset l0 p0
mset p0 l0
mcmp p0 g0
mset p0 g0
mset g0 p0

mcmp lp1 lp2
mset lp1 lp2
mcmp pl0 pl1
mset pl0 pl1
mcmp pp0 pp1
mset pp0 pp1









desliz mset gl0 1 madd l0 1 mless l0 5 end
setear las globales desde 0 hasta 4 en 1, pisando los triggers de cada una

desliz mcmp gl0 1 madd l0 1 mless l0 5 end mcmp l0 5
verdadero si las globales 0-4 son 1, pone un trigger en cada una

en estos casos los indirectos hacen lo mismo que los directos, nomas que ponen/pisan en la posicion que obtengan del otro
los triggers indirectos no son como los permanentes, se ponen dinamicamente y se sacan cuando se pisan (o no?). Si ya esta puesto no se vuelve a poner, pero se hace el intento





desliz mset gg0 1 madd g0 1 mless g0 5 end
deberia andar igual que el de local

desliz mcmp gg0 0 madd g0 1 mless g0 5 end mcmp g0 5
pone 2 triggers permanentes en g0
dinamicamente pone triggers en g0-4
el madd no activa triggers por ser de la misma pieza
como la memoria es global no se guarda el estado de cada iteracion, y el trigger va a dispararse en la primera iteracion del desliz (porque la memoria va a ser igual en cada iteracion), lo que es raro pero esta bien definido. Se tiene que usar memoria local para estas cosas







tiempos
base -O3
actual 100 turnos                         - 0.000021   0.000017   0.000017  0.000022
caballos caballos sin captura 1000 turnos - 0.000038   0.000056   0.000059
caballos reinas sin captura 1000 turnos   - 0.000251   0.000262   0.000281
caballos emperador sin captura 5 turnos   - 0.226628
caballos memoria 1000 turnos              - 0.000349   0.000377   0.000412
caballos memoria sin turno 2000 turnos    - 0.000020   0.000013   0.000014

poniendo un trigger por normal por posicion -O3
+no pone mas de un trigger por normal por posicion
+los trigger son de 8 bits
-cuando recalcula tiene que rehacer todas las condiciones 

mas rapido cuando hay normales con pocas condiciones

actual 100 turnos                         - 15    20    18   21
caballos caballos sin captura 1000 turnos - 39    39    58
caballos reinas sin captura 1000 turnos   - 251   262   281
caballos emperador sin captura 5 turnos   - 226628
caballos memoria 1000 turnos              - 349   377   412
caballos memoria sin turno 2000 turnos    - 20    13    14
test vel reina                            - 178   154   229
test vel reina con boludeces              - 337   244   340
caballos peon 2000 turnos                 - 13    17    24   19   15   20

haciendo que los triggers contengan cond que los puso -O3
+recalcula solo las conds necesarias
-triggers de 12 bits
-stable_sort
-pone un trigger por cada cond que pone triggers

mas rapido cuando hay normales con muchas condiciones

actual 100 turnos                         - 19    15  22  19
caballos caballos sin captura 1000 turnos - 57    46  51
caballos reinas sin captura 1000 turnos   - 354   242 246
caballos emperador sin captura 5 turnos   - 195875
caballos memoria 1000 turnos              crash
caballos memoria sin turno 2000 turnos    crash
test vel reina                            - 167   167  169
test vel reina con boludeces              - 473   524  388
caballos peon 2000 turnos                 - 17    19   20


La diferencia en la mayoria de los casos no es muy significativa
Me voy a quedar con la version que no pone mas informacion al trigger. Es un codigo mas simple, y parece ser ligeramente mas rapida en el caso mas general (normales con pocas condiciones). Tambien tiene espacio a optimizar, una de las optimizaciones mas recurrentes del otro metodo es saltarse el esp al recalcular, y eso es algo que se podría harcodear.


poniendo un trigger por normal por posicion -O3
actual 100 turnos                         - 15    20    18   21
caballos caballos sin captura 1000 turnos - 54    52    52
caballos reinas sin captura 1000 turnos   - 251   262   281
caballos emperador sin captura 5 turnos   - 226628
caballos memoria 1000 turnos              - 349   377   412
caballos memoria sin turno 2000 turnos    - 20    13    14
test vel reina                            - 178   154   229
test vel reina con boludeces              - 347   310   340
caballos peon 2000 turnos                 - 13    17    24   19   15   20

Otra cosa que se podría probar es poner una normal por posicion -O3
+un trigger por normal
+no recalcula innecesariamente (a menos que se trate de cosas de memoria)
+al haber solo un esp (o ninguno) por normal y forzar que este al principio se puede devirtualizar
-puede que tener muchas normales sea mas lento (aunque en el caso general siempre hay una normal por posicion)

actual 100 turnos                         - 16    18    17   21  12  16
caballos caballos sin captura 1000 turnos - 39    56    56
caballos reinas sin captura 1000 turnos   - 240   228   170
caballos emperador sin captura 5 turnos   - 227063
caballos memoria 1000 turnos              - 
caballos memoria sin turno 2000 turnos    - 
test vel reina                            - 148   135   139
test vel reina con boludeces              - 464   403   461
caballos peon 2000 turnos                 - 20    14    16   18   16   13

la reina con boludeces es mas lenta porque tiene un normal-esp exc normal, normal end, donde el trigger lo pone normal-esp. En el otro el trigger lo pone cada normal adentro de exc, por lo que hay que hacer manejo de listas de triggers y eso
Esto es medio problematico porque cosas como exc mover or capturar end son comunes. Pero bueno, creo que optimizar lo vale. Cosas muy repetidas se pueden poner adentro de una accion nueva. No va a ser un problema para la version compilada (esta puede poner la activacion del trigger donde quiera, no esta limitado a principios de normales)

haciendo que se salte esp en la regeneracion, y haciendo que solo esp ponga triggers

actual 100 turnos                         - 11    13   12   12  12  15 22 15 13
caballos caballos sin captura 1000 turnos - 52    39    42
caballos reinas sin captura 1000 turnos   - 245   310   310
caballos emperador sin captura 5 turnos   - 261658
caballos memoria 1000 turnos              - 
caballos memoria sin turno 2000 turnos    - 
test vel reina                            - 140   140   97 210 136
test vel reina con boludeces              - 235   257   335
caballos peon 2000 turnos                 - 20    20    17   14   19   14

Cuando se regenera la normal que puso un trigger no es necesario chequear esp porque esta asegurado que va a ser verdadero. No se puede decir lo mismo de lo que venga despues.
Se podría hacer otra version de generar sin esp o setear temporalmente esp a false. Habria que ver si lo vale

Cuando una normalHolder no varia su valor de verdad no es necesario seguir recalculando, ya que los otros operadores van a hacer lo mismo que hicieron la vez anterior. Para tener esto en cuenta hay que hacer otra version de generar que haga el chequeo de variacion y meta un longjmp si falla. 
Cuando hay varios triggers el sistema es mas complicado, solo hace el longjmp si es el ultimo trigger, sino funciona como generar
Despues de pensarlo un poco no creo que valga la pena. Agrega muchos chequeos para un caso muy raro. Lo peor seria que generara de mas, y eso pasaria especialmente en una generacion redundante de verdadero->verdadero. Y eso no va a pasar practicamente nunca.
Lo otro es una generacion de falso->falso,que no hace nada dentro de la misma cadena, pero puede que haga que un operador que contenga la cadena haga cosas de mas. Pero ese operador podria tener chequeos que lo eviten (si desliz y exc no hacen nada que no llamen a sig->generar())
A demas agregar algo asi implica que la normal que puso el trigger es la que tiene la condicion que necesita ser reevaluada, lo que es falso cuando hago w esp exc mover or capturar end y pongo el trigger solo en esp (que seria lo mas rapido, porque levanta un trigger solo)


Tambien aprovechando que cada normal tiene su pos saco la pos de cada cond, ahora hay una posActual que es offset+normal->pos directamente
Esto evita la suma en cada cond y acc, y ahorra memoria. Ahora la mayoria de las cond y acc no tienen algo que las haga unicas, asi que no necesito memoria dinamica.

(mejora en 1 o 2 microsegundos despues de hacer eso)




Aplicando memoria contigua

actual 100 turnos                         - 17    12   12   15  13  15 20 16 14
caballos caballos sin captura 1000 turnos - 47    45    48  31
caballos reinas sin captura 1000 turnos   - 255   142   194
caballos emperador sin captura 5 turnos   - 185508
caballos memoria 1000 turnos              - 
caballos memoria sin turno 2000 turnos    - 
test vel reina 1000                       - 115   82    115 113 114
test vel reina con boludeces 1000         - 237   253   255         
caballos peon 2000 turnos                 - 18    19    15   16   19   13

tamaños
normal 112
movs   143168
ops    34832

base puntero
actual 100 turnos                         - 14    16   19   17  15  13 13 13 12
caballos peon 2000 turnos                 - 19    20    14   19   16   19 13
test vel reina 1000                       - 135   116    115 97 113
normal 96
movs   126528
ops    34832
#parece ser que es ligeramente mas lento (o no?). Lo voy a dejar estar porque ahorra memoria y eso va a ser importante ahora que voy a empezar a copiar pedazos importantes durante el runtime. Ademas la memoria va a ser cada vez mas chica, y la realentizacion que esto tiene va a bajar con eso.


stuffed bools
actual 100 turnos                         - 16    16   16   18  13  12 15 13 14
caballos peon 2000 turnos                 - 20    20    19   19   13   18 15
test vel reina 1000                       - 100   128    181 179 80 79 116
normal 80
movs   107968
ops    33376
#noto que hay mas variacion entre corridas, si se mira nomas los minimos ahora es mas rapido que antes
















Graficos
Agregar boton que muestre las memorias. La global se vería todo el tiempo. Si se toca un espacio se dibuja la memoria de tile y la de pieza si hay una pieza en esa pos.
En modo debug se dibuja la memoria de movimiento mientras este se calcula, y se redibujan todas en cada paso

%%%

WhenNoMoves
Ahora cuando un jugador se queda sin movimientos y es su turno el juego queda en softlock. Se podría dejar asi y listo. Una solucion desde adentro del lenguaje es agregar un boton de rendicion. 
Se puede agregar un sistema que detecte esto. No estoy seguro de si lo valga, agrega chequeos cada vez que se acciona. Para adaptarse a cada juego posible tiene que chequear si los dos jugadores tienen movimientos posibles despues de cada accionar.
Se sabe que un jugador tiene movimientos si tiene un holder que tenga un movimiento que tenga su primer movholder con valorCadena verdadero.
En primera instancia se podría mirar el holder que genera despues de moverse y los que reaccionan para ver si estos hacen algo. Si eso falla se va a tener que recorrer el tablero buscando algun holder que cumpla la condicion. Si no hay ninguno se llega a la conclusion de que no hay movimientos.
Cuando pasa esto, se corre el codigo WhenNoMoves asociado a ese jugador
-
Lo que no me convence de este sistema es que es relativamente lento e invade todos los juegos, cuando no necesariamente todos lo usen, y no es algo totalmente escencial. 
Por ahi tendria mas sentido como algo opcional para la version compilada
Cuando los dos jugadores se bloquean al mismo tiempo andaria medio raro, pero supongo que se puede salvar desde el lenguaje. 


 


### IA
aparentemente el segundo orden es solo usado por la IA. Ya que lo estoy haciendo podría agregar comandos que lo aprovechen, pero la verdad es que no hay mucho que se pueda hacer que no se pueda hacer usando memoria y triggers o every, y esas soluciones suelen ser mas limpias y eficientes. 

Los triggers de segundo orden son necesarios porque aumentan mucho la eficiencia, pero habria que ver como agregarlos sin molestar a los juegos que no lo usen. Supongo que si son iguales a los triggers de primer orden no habria problema



hacer modo debug donde se muestre el movimiento elegido medio transparentado. Cuando se elige una pieza se muestra el valor que se le dio a cada movimiento sobre su clicker. Se puede mover cualquier pieza.

Hay un espacio de memoria que la IA lee y limpia al final de cada movimiento, antes de dar la valoracion final. El valor leido se suma directamente al valor. Sirve para que se pueda influir artificialmente en la valorizacion. Agregar una IA que solo se maneja con esto


###

/// threads
Agregan mucha complejidad y puede que no sean muy necesarios, ver

Alguna opcion visual para ver que piezas se estan calculando actualmente



///

---mas cosas

por ahi agregar funciones para no blotear tanto con macros. No creo que cambie la eficiencia pero bueno. No debería ser muy complejo ya que no tienen parametros, si se les necesita pasar algo se pasa por memorias

una matriz extra del tablero para sprites solo esteticos

una matriz extra del lector para valores iniciales de la memoria tile, y otra para sprites esteticos

neg, operador que tiene una normal y retorna el valor opuesto. Hace un chequeo que mira que la normal solo contenga condiciones

forma mas simple de dar doble turno y cosas asi, preferiblemente sin agregar nada

agregar un break a desliz, se usaria bastante. Por ejemplo en la torre:
desliz {w,a,s,d} exc mover or captura break end

checkid a, comando que da verdadero si el id de la pieza en esa pos es a

Modo debug, se elige en la pantalla del tablero.
Hace que se hagan pausas en el calculo de movimientos, que se avanzan de a una apretando una tecla. Sirve para debuggear movimientos y para explicar como funciona el sistema. Se marca la pieza actual, se dibuja el movimiento parcial y donde esta el puntero de posicion. 
No estoy seguro de que determina las pausas
Cuando se esta en este modo solo hay un thread
-
En la implementacion supongo que voy a hacer otro calcular, para no meter un if(debug) en el calcular normal

opcion de ver todos los movimientos de un bando

Se podría agregar un operador rand que es una especie de opt, pero solo
corre una rama elegida aleatoriamente
En el lenguaje se tendría que escribir un porcentaje en cada rama, y todas
las ramas tienen que sumar 100
Dentro de todo es simple y da bastante juego.
En la IA se puede implementar haciendo una cuenta que tome el valor y riesgo de 
hacer cada movimiento, pesados por su probabilidad
Un problema de generalizacion es este: Hay dos ramas, una verdadera y una
falsa. Debería descartarse la falsa y solo tener en cuenta la verdadera, o
elegir aleatoriamente entre las dos y si cae la falsa no hacer nada?
Como se puede abstraer para tener los dos casos? Una forma sería con un
flag y ya esta



lo mas eficiente para partidas humano vs humano sería calcular el movimiento de la pieza que el jugador toca y listo, en vez de generar todos los movimientos y ir recalculando. Pero hacer esto inhabilita el segundo orden, y las acciones en condiciones. Y a demas va a congelar el juego por un milisegundo cuando se toca la pieza, mientras que el otro sistema calcula antes de que se toque la pieza y el jugador esta pensando.
Se podría agregar como optimizacion de algunos casos, pero es algo de trabajo y probablemente haga el juego parecer mas lento, asi que no lo vale. Hacer lo mismo para todo es mas simple y limpio.







