
Hay que hacer que los movimientos se guarden en memoria para evitar recalcularlos constantemente

La IA evalua el tablero por cada movimiento, y evaluar el tablero implica calcular todos los movimientos.
Si los movimientos se guardan en memoria solo va a ser necesario recalcular los movimientos de la pieza que se movio
y las que sean afectadas por eso
(si n es la cantidad de movimientos y extra los movimientos de piezas afectadas la cantidad de calculos en el primer turno
es 2n+extra, y en el proximo es n+extra. Sin guardan en memoria la cantidad de calculos es n^2 en todos los turnos)

Tambien se ahorrarían recalculos para ver si hay jaque

--

El lenguaje da las instrucciones para formar movimientos
Hay 3 estructuras de movimiento, normal, desliz y opt.

los movimientos tienen en comun:
bool estado, valido o invalido
lista pos triggers, si una de estas posiciones se pisa o se deja por la pieza que se esta movimiendo se tiene que recalcular
(debería haber varios tipos de triggers, de chequeo de vacio, enemigo, etc? por ahi no, nomas serían utiles es casos raros
y aun asi no cubririan todos los casos)
lista acciones, con las acciones marcadas en posiciones absolutas
next, para encadenar movimientos
tambien podrían tener un enum que los identifique, para hacer algunas optimizaciones especificas (si hay)

en un movimiento normal:
cuando se activa un trigger, siendo el estado valido o invalido, se recalcula.
En la gran mayoria de los casos si el estado es valido se vuelve invalido, aun asi habría que recalcular por casos raros

desliz:
contiene una lista de movimientos, que genera a partir de un movimiento interno
su estado es valido si el primer movimiento es valido, en la lista de movimientos todos menos el ultimo son validos
cuando falla un trigger se invalidan todos los siguientes movimientos en la lista y se recalcula el fallado, reconstruyendo
si hay un next se corre cuando falle el ultimo

desliz genera los movimientos conforme los chequeos de su movimiento interno sigan dando verdadero, por lo que va ocupando
memoria con movimientos absolutos. Cuando fallan se borran. 
Por ahi podría no borrarse y mantener la memoria reservada, habría que ver. (si termina siendo necesario)


la ventaja de hacer desliz una estructura es que una cadena de movimientos se guarda como una cadena de movimientos, no
una lista de movimientos donde cada elemento tiene una copia del anterior mas un paso mas
y tambien da lugar a un manejo mas inteligente de los recalculos, ya no es necesario recalcular toda la cadena, solo
lo que venga despues de un trigger
para recalcular avanzado habría que guardar la pos de cada inicio de mov o algo asi, no debería ser complicado


desliz se tiene como siguiente a si mismo para manejarse bien con las ramificaciones de opt, si usara un bucle while habría
que crear una estructura de control para cada ramificacion de opt

opt:
contiene una lista de movimientos internos que usa para crear ramificaciones, tambien una lista de acciones y triggers para
cada rama.
Se limita a recalcular solo la rama que haya disparado un trigger.

--


los movimientos se guardan en memoria como una accion y una pos. Ocupa mas espacio y hay muchas posiciones repetidas,
pero hay que calcular menos cuando se hacen los calculos de movimientos y eso es lo que necesita mas velocidad.
Se van a tener que copiar mas posiciones pero no se van a tener que copiar las instrucciones que cambiaban la posicion.
A demas la posicion global tarda mas en acceder, debe ser eso lo que realentiza
Y es algo que se abstrae del lenguaje.

se manejan desde controladores de normal, desliz y opt

dentro de normal:
las condiciones si son falsas invalidan el movimiento y dejar un trigger en esa pos. Hasta que no se dispare ese trigger
ese mov queda invalidado.
si es verdadero se dejan triggers y se sigue mirando hasta terminar. 

No sé si opt exc se va a poder agregar sin muchos problemas, en cualquier caso hacer un operador exc o if que haga eso y listo




Actualmente cuando se toca una pieza a partir de las instrucciones se generan clickers, que crean una copia
de el buffer de acciones y de colores. No hay distincion entre desliz, opt y normal a este nivel, los clickers
se crean de forma explicita

el sistema nuevo tendría que crearlos usando las estructuras que tambien usa la IA, asi queda todo con lo mismo y no
hay un quilombo de cosas. A demas el sistema anterior tenia cosas raras, ver si se puede hacer algo con para que no
pasen en este


Una vez hecha la generacion va a quedar una lista de movimientos con posiciones absolutas dentro de 
las estructuras (normal, desliz, opt).

No sé si hay una forma clara de delimitar movimientos, puede que necesite poner una especie de click.
Por ahi se puede hacer solo usando unos flags y aprovechando que las estructuras ahora son diferenciables.
-al llegar a una normal sin continuacion
-en cada elemento de la lista de un desliz nc
-aplicando las mismas reglas en cada rama de un opt
y arrastrando todo lo que haya atras

la forma de identificar estos movimientos en las estructuras debería ser rapida, iterable y referenciable.
La IA va a necesitar obtener un elemento, hacer algunas acciones, y luego obtener el proximo. 
Los clickers van a necesitar alguna forma de referenciar que elemento de la lista de movimientos, y de que a que punto,
hace referencia
Hay que tener en cuenta que los movimientos se van a leer muchas veces

Supongo que lo mejor va a ser tener una funcion que devuelva
un movimiento en forma de lista de normales. La proxima vez que se la llame va a dar otro.
Va a usar una estructura interna para saber cual es el siguiente o terminar
Tambien se puede guardar y restaurar
esta lista de normales es lo que se guarda en los clickers. La lista es de punteros para que sea rapido y simple

Un tema es que la IA va a tener que usar esa funcion muchas veces para acceder a los mismos movimientos.
(en cada iteracion del analisis de tableros. Abstraer el movimiento asi es util porque los recalculos no afectan nada)
Aunque la funcion debería ser bastante rapida y no debería dar problemas.
Guardar las normales en memoria y cambiarlas en caso de recalculo es una opcion, pero puede que mantener las listas
en memoria y hacer chequeos de reemplazo y reemplazos a demas de ser complejo termine siendo mas lento. 
La funcion solo debería hacer unas comparaciones de ints antes de devolver una lista de normales.

La funcion recibe un vector<normalHolder*>* para evitar tener que armar la lista y despues copiarla a el clicker o la
estructura de control de la normal. Si la funcion no puede generar nada devuelve falso y listo, si puede genera, lo tira
en ese puntero y eso se pasa al constructor de clicker



limites y memoria
estos funcionan durante el chequeo de condiciones, esta parte esta bastante intacta, no debería haber problemas
Como en el producto final solo quedan las acciones no debería haber uso de memoria en el resultado final, es un condt
la memoria era movt por posrestore y posremember nomas. Estos se pueden implementar como actt que tienen la pos seteada
en la fase de condiciones
en desliz y deslizopt se va a tener que guardar el estado de memoria para retomar calculos, pero solo ahi

bloque
bloque<contenido> = opt<contenido TERMINAR,>
podría hacerse como un opt agregando un comando de terminar forzazamente el movimiento, o como una estructura unica.
Hacer una estructura unica es gratis y es mas limpio
Usaría un solo int de control, 0 hace que devuelva su normal y termine el movimiento, 1 hace que no haga nada

De la misma forma podría agregarse un exc asi no bloteo opt




Lo primero a implementar es sacar las instrucciones de movimiento, y poner la pos directamente en las acciones.
En terminos de memoria es mas o menos lo mismo porque cada movimiento implica un puntero mas, se ahorran espacio
si hay muchas acciones en una posicion pero se pierden si hay muchos movimientos.
Y tener posiciones relativas va a ser mas facil conseguir absolutas, y las absolutas hacen todo el proceso mas simple y
rapido
Dentro de una normal las posiciones relativas son fijas
Supongo que los graficos van a estar ligados a la normal, aparte de las acciones para ser toggeables. Se van a manejar igual,
con posiciones absolutas y eso. En el sistema nuevo va a haber muchas menos copias al pedo de un mismo sprite, y usando
indireccion se podría hacer que sean re pocas, una por RGBA usado, no se si es al pedo igual

no hay necesidad de acm porque las pos van a estar en cada cosa

De paso desglobalizar todo para no tener problemas de thredeado

lo unico malo de thredear es que tengo que pasar por parametro la pos, el holder y el tablero del thread. Pero bueno, no
creo que traiga mucho problema
Supongo que lo mejor para esto va a ser meter la pos y el tablero dentro de holder y pasar solo holder. Total el tablero
se accede pocas veces y aunque la pos se accede muchas veces es mas rapido acceder a ella que copiarla, supongo
variables como outbounds se van a tener que guardar en holder
los movimientos absolutos y triggers tambien, dentro de las estructuras de normal y eso

la ventaja de tener el tablero como una matriz de punteros es que preguntar si una pieza esta en una posicion es directamente
mirar en la matriz, en lugar de recorrer un vector de piezas comparando numeros
Por otro lado, tener la pos guardada en el holder seria un poco mas comodo porque se tendría que pasar un parametro menos
en las llamadas a funcion, aunque en la mayoria de los casos despues se va a tener que obtener la pos de ese puntero. Aun asi,
puede que sea mas rapido. La pos se determina antes de llamar a calcular movimientos segun la matriz, y se suma a los valores
relativos de cada movimiento.

el desliz despues de cada iteracion setea pos a la pos del ultimo movimiento de su lista



cuando se intente calcular los movs de un holder, en un primer turno:
se calculan todos los movimientos, lo que implica obtener todos los movimientos de pieza, que ya tienen las posiciones
relativas armadas, transformar las condiciones a absolutas y probar que anden.
si andan, traducir las posiciones de las acciones y guardarlas (por ahora alocando y borrando, despues intentar no borrar)
(se guardan en el holder, es algo unico de este)
Las condiciones tambien guardan una lista de posiciones que se usa de trigger (no me parece util diferenciar entre distintos
tipos de triggers), conforme se vayan evaluando, cortando antes si es falso
En los proximos turnos se recalculan movimientos solo si se pisan triggers


En holder van a estar los movimientos absolutos y los triggers, dentro de estructuras de control
En pieza van a estar los movimientos relativos y las condiciones

En cada turno se recorren todos los holder para ver si alguna estructura de control activo un trigger. De hacerlo,
la misma va a llamar a la parte correspondiente en pieza para recalcular
Por lo que cada estructura de control va a necesitar un puntero a su estructura correspondiente en pieza, y tambien 
pasarse a si mismo como parametro. Quedo medio raro
Supongo que basta con un puntero a funcion, sino un puntero a objeto

si se activa un trigger en normal llama a normal en pieza y este recalcula, pasa todas las condiciones y acciones
las normales solo se generan a traves de deslices, por lo que estos deberían ser los encargados de armarlas, ademas
del arme inicial. Asi evito tener ifs de generado adentro de las normales y se aceleran un poco las cosas

tengo que ver como copiar los accs de pieza a holder


Desliz manda a revisar triggers a su contenido. Si alguno se activa, manda a recalcular a este y a los siguientes
Por ejemplo, si tiene normal la primera normal que se active y las siguientes llamarian a pieza
si tiene desliz, este desliz haria lo mismo con sus normales y si hubo recalculos le avisa a desliz, y todas las proximas
iteraciones se recalculan
la pos a adelantar se obtiene de el ultimo elemento de la ultima normal.
No sé si va a haber problemas con opts, verlo cuando esten mas pensados
Como voy a hacer opt distinto hacer que desliz no se llame a si mismo ocupando el stack al pedo


Desliz crea una nueva instancia de contenido en holder, de necesitar, antes de llamarla a calcular, y pieza la setea.
Asi se ahorra tener que crear y destruir al pedo

Opt como esta ahora no sirve porque genera los datos al aire. Cuando esta adentro de un desliz genera una estructura
de arbol y desliz genera listas. No hay forma de meter el arbol en la lista, al menos no una forma simple que se haga
desde adentro de un opt no conciente de que esta en un desliz. Y aunque hubiera una solucion tendría que tener en cuenta
todos los casos raros de anidacion y demases
-
Una solucion desde adentro de opt es hacer que cada vez que se lo llame genere sus 2 entradas (suponiendo que tenga 2 ramas),
la proxima vez 2^2 y asi, estableciendo una relacion numerica entre cada uno. (el de la pos N le siguen 2N y 2N+1).
El tema de esto es que opt necesita saber cuantas veces se lo llamo, y cosas como recalcular son complicadas. Tampoco estoy
seguro de que funcione con casos raros, y la estructura termina siendo medio bizarra
-
otra solucion es crear una estructura deslizopt que se arme en una segunda barrida, haciendo algo como
desliz n1 opt n2 , n3 end n4 end => deslizopt(n1,(n2,n3),n4)
Sería lo mejor porque se llevaria bien con cualquier tipo de anidacion rara, y maneja los casos de tener cosas 
antes y despues de opt de la forma mas eficiente. Crea la estructura de arbol directamente sin tener que hacer cosas
rebuscadas. Es lo mas limpio.
Igual dejar esto para mas adelante, ahora no es algo necesario.
Tambien esta el tema de tener desliz opt n1 n2 end n3 opt n4 n5 end end, cosas como esta podrían directamente prohibirse
porque nomas se dan en casos muy raros y pueden reescribirse de forma que no creen problemas y se mantengan igual











porRestore se deberían sacar porque no siguen en esquema de que cada normal tiene posiciones relativas fijas
(lo que no es una restriccion necesaria pero las demas cosas la cumplen y simplifica un poco),
por ejemplo w posRestore w no se podría pasar a relativas fijas. A ori, si actua solo dentro de una normal, no le 
veo mucho sentido.
posRestore no se usaria casi nunca pero tener algo que cargue posiciones a memoria permite hacer las piezas que
promocionan en tal lugar sin usar contadores. Tambien se podría replicar un posRestore haciendo un desliz de normales que
cuenten y avancen.



Optimizacion:
cuando falla un trigger de una normal no es necesario verificar todas las condiciones, solo la que generó ese trigger.
El tema es que los triggers no se diferencian y no hacen referencia a sus condiciones, y si lo hacen terminario siendo
todo mas lento
Pero puede que se pueda relacionar un trigger con su condicion por la posicion en la que esta en la lista. El trigger #3
debería corresponder a la condicion #3 de la normal. Seguro que esto varia un poco ya que no todas las condiciones
generan triggers, pero aun asi puede hacerse algo


--


Creo que no hay ninguna condicion no posicional que importe. Se podría dar que una pieza base su condicion en una propiedad
de otra y cosas como every cambien esa propiedad. En estos casos especificos se podría hacer que un cambio en una pieza
active los triggers que esten sobre esa pieza





