
El codigo que arma los movimientos si estuviera hecho funcionaria asi:

Hay una cadena de operadores, algunos de ellos pueden tener ramas internas con cadenas. Esto se forma a partir del lenguaje de piezas.
Cada holder tiene una copia de este arbol, con la version movholder de los operadores. Estos tienen el codigo que corre durante el juego. Los operadores solo contienen la estructura y los datos de las normales, ya que estos son iguales para todos los holders de una misma pieza.


Cuando se llama a generar se va pasando el control llamando a una funcion polimorfica en cada operador, si es una normal genera el movimiento, si es otro operador hace sus cosas.

Cuando se activa un trigger se va al inicio del movimiento y se recorre buscando la que marcó el trigger. Desde que se encuentra en adelante se genera

Cada normal tiene un puntero a unos datos que le indican que condiciones chequear en que pos relativas. Estas posiciones se vuelven absolutas, se hacen todos los chequeos. Si todos pasan se guardan pos absolutas sobre las que se van a hacer las acciones.
Toda la cadena de condiciones y acciones son de elementos polimorficos

La memoria de movimiento esta en una base que todos los movholders conocen


Esta estructura funciona y dentro de todo no es muy compleja, y hace todas las funcionalidades que necesito.
De todas formas no me termina de cerrar porque es la parte critica del codigo y usa mucha indireccion, por un lado esta la estructura de movholders y ademas adentro de normal tenemos las cadenas de movs que tambien son polimorficas

De todas formas voy a terminarla y probar que ande bien


La alternativa que sería mas rapida y mas flexible sería hacer que el lenguaje de piezas compile a codigo en c++
Hace el arranque mas complejo:
Habria un programa inicial que te da a elegir el tablero. Una vez elegido, el programa genera el codigo de las piezas, lo compila junto con el resto del juego y lo arranca. (Puede que parte del juego este compilada y espere que se linkee, no sé)
Tambien esta el tema de que debería andar con varios compiladores, lo unico que debería cambiar es la llamada nomas igual

La gran ventaja de generar codigo es que ahora toda la estructura de movHolders y movimientos es inline.
Tambien se pueden agregar optimizaciones especificas como no meter control de memoria en movimientos que no usan memoria, no necesitar pasar argumentos de mas a movs que no los necesiten, separar esp de otras conds, no recalcular posAct si no se mueve, agregar un solo trigger por pos, etc
Puede tener una desventaja menor de que al generar codigo hay mas bloat y eso afecte a la cache, pero no creo. Y hasta cierto punto se puede regular decidiendo si hacer inline de los movimientos o no.

Puede que la separacion entre operador y holder ya no tenga sentido en este modelo. Podría hacerse que el holder contenga las estructuras necesarias para funcionar, que pueden variar (a demas de los datos de holder, una normal sola solo tendría el array de acciones, pero un desliz necesita un vector de normales y algunos datos de control) y operador sea solo la funcion generar

ej
w vacio mov
->
(los movimientos probablemente esten inline)
void mov.generar(data* dat){
    v posAct;
    posAct=data->pos+v(0,1);
    if(!esp(posAct)){
        valido=false;
        return;
    }
    agregarTrigger(posAct);
    if(!vacio(posAct)){
        valido=false;
        return;
    }
    posAct=data->pos+v(0,1);
    data->accs[0].pos=posAct;
}

agregarTrigger sería algo como 
tablero->tile(posAct)->triggers.push_back(Trigger(this,1));

el 1 es un numero de control para el mecanismo de reaccion. 
No tengo claro si usar una la funcion de generar para reaccion y generar, o tenerlas como cosas separadas. Supongo que juntarlas es mejor porque hay menos bloat para la cache. El unico costo de juntarlas es un chequeo de mas
-
el mecanismo de reaccion es complicado. Si fuera todo plano sería un switch con gotos al principio de la funcion, pero con desliz eso no funciona directamente.
Una solucion que creo que funcionaria para todos los casos es ir asignando numeros a cada eslabon del desliz cuando se genera. En el switch hay un for por cada desliz que mira el numero que se pasó es de ese desliz. Si lo es se salta a este acomodando su iterador. Esto se puede hacer andar con anidacion. Los iteradores entonces quedan ligados a un valor generado en runtime. La n-upla que guarda esto se genera cuando se compila. 
No sé si es la solucion mas simple
Tambien tiene que guardar un offset para pos 






desliz w vacio mov end

void mov.generar(data* dat){
    v posAct;
    posAct=data->pos;
    i=0;
    while(true){
        posAct+=(0,1);
        if(!esp(posAct)){
            cap=i;
            return;
        }
        agregarTrigger(posAct);
        if(!vacio(posAct)){
            cap=i;
            return;
        }
        posAct=data->pos+v(0,1);
        data->norm[i].accs[0].pos=posAct;
    }
}




Algo bizarro que se podría agregar facil es la habilidad de poder insertar codigo en c++ directamente adentro del lenguaje de piezas, escribir algo como
desliz w mover <@for(int i=0;i<50;i++) cout<<"dasda";@> end
(el codigo se marcaría como condicion o accion con alguna notacion. El codigo que se genera esta dentro de una funcion bool o void, respectivamente)
No sé si hay algun contexto en el que sea util, pero estaría bueno. 
Se podría llamar a comandos comunes usando los nombres de las funciones, como 
mov(), etc. Como no es el lenguaje de piezas el que esta llamando cosas como esp no se van a poner automaticamente, los movimientos del puntero no se van procesar junto con las del lenguaje, etc. Pero si uno es conciente de estas limitaciones no habría problema.

https://stackoverflow.com/questions/36150706/how-to-ask-programmatically-a-compiler-to-compile-a-file-in-c

























