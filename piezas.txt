
>green=color 0 255 0;
>red=color 255 0 0;
>blue=color 0 0 255;

#TEST NO TOCAR
>TW&=w|a|s|d;
>TWA&=wa|wd|sa|sd;
>TWASD&=TW|TWA;
>Tmover=vacio mov green;
>Tcaptura=enemigo capt mov red;
#/TEST




>mover=vacio mov green;
>captura=piece capt red;

>W&=w|a|s|d;
>WA&=wa|wd|sa|sd;
>WASD&=W|WA;

:1 0 #peon
#mcmp t0 0 mset t0 1 W mover;
#mcmp t0 1 WA mover;
#msize g 10 mless g0 10 madd l0 g0 madd l0 1 mset g0 l0 mset gg0 l0;
#msize l 10 desliz mless l0 10 madd l0 1 mset ll0 l0 end;
#desliz WA mover capt spwn 2 end;
#desliz WA mover isol capt spwn 2 end end;
#TW Tmover TW vacio spwn 1 color 0 0 255;
pass;

:2 1 #torre
desliz W mover c end W captura;

:3 2 #caballo
>A=ww|ss;
>A2=a|d;
>B=aa|dd;
>B2=w|s;
>C=A A2|B B2;
C exc mover or captura end;
#{{ww,ss}{a,d},{aa,dd}{w,s}} exc mover or captura end

:4 3 #alfil
desliz WA mover c end WA captura;

:5 4 #reina
desliz WASD mover c end WASD captura;

:6 5 #rey
WASD exc mover or captura end;

:7 5 #emperador
desliz w end desliz a end
desliz isol desliz isol mover c end d end end s end;

:8 0 #test caballos
#{{ww,ss}{a,d},{aa,dd}{w,s}} mover
#desliz {w,wa,a,as,s,sd,d,dw} exc mover or mcmp l0 2 captura end c end
#desliz w end desliz a end \
#desliz isol desliz isol mover end d end end s end
#w mover mcmp l0 l1
#desliz exc w mover or a mover end c end
#mcmp p0 0 w mover mset p0 1
#mcmp p0 1 s mover mset p0 0
#{w,a,s,d} mover

#w mover mset p0 1 exc mcmp y 31 capt spwn 5 or pass end
#{wa,wd} mset p0 1 captura exc mcmp y 31 capt spwn 5 or pass end
#ww mcmp p0 0 mover mset p0 1
desliz {w,wa,a,as,s,sd,d,dw} mover c end

:9 7
desopt wa mover c or wd mover c end
#desopt wwa isol mover c end or wwd isol mover c end or aaw isol mover c end or ddw isol mover c end end 
s mover
#desopt wa mover madd l0 1 mless l0 2 or wd mover madd l0 1 mless l0 4 end
#mset l0 -1 desopt \
#       mdist l0 3 wa captura wa mover pausa mset l0 0 or \
#       mdist l0 2 wd captura wd mover pausa mset l0 1 or \
#       mdist l0 1 sa captura sa mover pausa mset l0 2 or \
#       mdist l0 0 sd captura sd mover pausa mset l0 3 end #dama que no se banca bucles
           #l0 iterador, l1 tamaño, l2 en adelante array de posiciones



:10 2
{a,d,w,s} mover

:11 3 #memoria
#mmore T p0 mset l0 T madd l0 3 mset p0 l0 w mover
mcmp t0 1 a mover
mcmp x y d mover
w pieza mcmp o1 1 ss mover
mcmp p1 1 aw mover mset t0 1 mset p1 0
mcmp p1 0 dw mover mset p1 1

:12 7 #dama que solo captura kakeada
>newPos= mset l0 2 desliz 
          mless l0 l1 exc 
           mdist x ll0 madd l0 2 
          or 
           madd l0 1 mdist y ll0 madd l0 1 
          end 
         end 
         mcmp l0 l1;
>addPos= mset ll1 x madd l1 1 mset ll1 y madd l1 1;
msize l 20 mset l1 2 desopt
       wa captura wa mover newPos addPos c or 
       wd captura wd mover newPos addPos c or 
       sa captura sa mover newPos addPos c or 
       sd captura sd mover newPos addPos c end;

#el problema con la anterior es que puede haber bucles donde se pase 2 veces por el mismo lugar,
#y como se guarda donde se para se invalidarian.
#la solucion es guardar las piezas capturadas en vez de el lugar donde se aterriza
:13 6 #dama que solo captura
>newPos= mset l0 2 desliz 
          mless l0 l1 exc 
           mdist x ll0 madd l0 2 
          or 
           madd l0 1 mdist y ll0 madd l0 1 
          end 
         end 
         mcmp l0 l1;
>addPos= mset ll1 x madd l1 1 mset ll1 y madd l1 1;
msize l 20 mset l1 2 desopt
       wa enemigo wa exc vacio or self end sd newPos addPos capt red wa mov green c or
       wd enemigo wd exc vacio or self end sa newPos addPos capt red wd mov green c or
       sa enemigo sa exc vacio or self end wd newPos addPos capt red sa mov green c or
       sd enemigo sd exc vacio or self end wa newPos addPos capt red sd mov green c end;

:14 6 #dama que captura y mueve
>newPos= mset l0 4 desliz 
          mless l0 l1 exc 
           mdist x ll0 madd l0 2 
          or 
           madd l0 1 mdist y ll0 madd l0 1 
          end 
         end 
         mcmp l0 l1;
>addPos= mset ll1 x madd l1 1 mset ll1 y madd l1 1;
msize l 22 mset l1 4 desopt
       wa enemigo wa exc vacio or self end sd newPos addPos capt red wa mov green mset l2 1 c or
       wd enemigo wd exc vacio or self end sa newPos addPos capt red wd mov green mset l2 1 c or
       sa enemigo sa exc vacio or self end wd newPos addPos capt red sa mov green mset l2 1 c or
       sd enemigo sd exc vacio or self end wa newPos addPos capt red sd mov green mset l2 1 c end
    mcmp l2 0 isol wa mover c end isol wd mover c end isol sa mover c end sd mover c;

#la cosa seria registrar en una memoria pos de capturas y el aterrizaje, teniendo al principio un contador de puntos.
#despues del desopt tendría que encontrar el maximo de las memorias, y armar el camino
#supongo que va a haber 2 pass, el primero para encontrar el maximo y el segundo para armar, porque puede haber empates.


#optimizaciones:
#hacer que la lista de pos se recorra de atras para adelante, la mayoria de las veces es el ultimo el repetido
#por ahi guardar en una variable en que direccion se movio, para evitar moverse en la direccion opuesta
#en vez de guardar posiciones guardar un bitfield del tablero, que mediria la mitad porque se usa solo un color



#PIEZAS PARA TEST
#desopt que haga un arbol de 4 de altura para arriba y para abajo. Como ahora la memoria se mantiene entre ramas va a necesitar un control en memoria que maneje eso
#pieza que implemente desopt usando deslices, exc y memoria. Para boludear mas que nada, igual estaria bueno ver la eficiencia ganada, ademas de la legibilidad, por hacer desopt un operador basico.

#####TEST

#ajedrez sin jaque, enroque y corte al paso
#el corte al paso lo pense como escribir en la tile el turno anterior,
#y para eso necesito poder llevar un contador de turno, y para eso necesito
#codigo suelto


:21 0 #peon 
>promover = isol mcmp y 7 capt isol spwn 23 end spwn 25 end; 
w Tmover mset p0 1 promover;
>X=wa|wd;
X Tcaptura mset p0 1 promover;
mcmp p0 0 ww Tmover mset p0 1;

:22 1 #torre
desliz TW Tmover c end TW Tcaptura c;

:23 2 #caballo
>A=ww|ss;
>A2=a|d;
>B=aa|dd;
>B2=w|s;
>C=A A2|B B2;
C exc Tmover or Tcaptura end;

:24 3 #alfil
desliz TWA Tmover c end TWA Tcaptura c;

:25 4 #reina
desliz TWASD Tmover c end TWASD Tcaptura c;

:26 5 #rey
TWASD exc Tmover or Tcaptura end;


:27 0 #peon con isols
>promover23 = mcmp y 7 capt spwn 23; 
>promover25 = mcmp y 7 capt spwn 25;

mcmp p0 0 
 isol ww Tmover mset p0 1 end 
 isol w Tmover mset p0 1 end
 isol wa Tcaptura mset p0 1 end
 wd Tcaptura mset p0 1;
mcmp p0 1 
 isol w Tmover promover23 end
 isol wa Tcaptura promover23 end
 isol wd Tcaptura promover23 end
 isol w Tmover promover25 end
 isol wa Tcaptura promover25 end
 isol wd Tcaptura promover25 end
 ;

:28 0 #simple
TW Tmover; 

:29 3 #spawner simple
#TW Tmover TW exc vacio spwn 29 or pass end;
TW Tmover TW vacio spwn 29 color 0 0 255;

:30 2 #local y pieza #probar meter un isol para los desliz
mset l0 p0 madd l0 1 desliz mdist l1 l0 TW isol Tmover mset p0 l0 end madd l1 1 end; 

:31 0 #tile 1
mset t0 1 TW Tmover;

:32 2 #tile 2
TW mcmp t0 1 mover mset t0 0;

:33 5 #emperador
desliz w end desliz a end 
desliz isol desliz isol mover c end d end end s end;

:34 2 #desopt
>X&Y=wa&wd|sa&sd;
desopt 98 X mover c or Y mover c end;

:35 2 #spam en lugar de desopt
>X=wa|wd;
>Y=X X X X X|X X X X|X X X|X X|X|;
X Y mover;
>X=sa|sd;
>Y=X X X X X|X X X X|X X X|X X|X|;
X Y mover;

:36 #dama

:37 4 #reina que no captura
desliz TWASD Tmover c end; 






