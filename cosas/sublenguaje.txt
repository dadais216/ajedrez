El fin del sublenguaje es crear una forma de almacenar informacion sobre movimientos de piezas.
Usar un sublenguaje permite poder crear movimientos complejos combinando distintos tipos, creando secuencias, etc,
sin necesidad de crear codigo especifico para cada caso posible.
El lenguaje permite usar funciones basicas y crear funciones a partir de estas.

Toda funcion devuelve un valor booleano, y recibe un vector o lista de vectores. 
Hay funciones de segundo orden

salto a : vacio a then mover a

a es un vector
salto a : declara una nueva funcion a
vacio a es una funcion basica que mira si a esta vacio
then es una funcion de segundo orden infija que da falso si su primer parametro de falso, y no lee el segundo. 
Si el primer parametro es verdadero, pasa al segundo

mover es una accion. Las acciones tienen un efecto real y siempre devuelven verdadero. Ese efecto real no se
dispara al interpretarse la expresion, la expresion solo esta para formar el clicker. La accion se dispara
si se elige ese clicker
Supongo que cada vez que se encuentre una accion se agrega a una lista, y esa lista es lo unico que se le da al clicker.

-por ahi no vale la pena añadir la creacion de funciones, puede que sea mucho quilombo y se use poco. 
-va a ser mas facil y se va a usar mas cosas como comparacion booleana y funciones de segundo orden,
-asi que hacer que cosas como salto, captura y estandar ya vengan hechas, el resto se van a escribir a mano
-cuando se necesiten usando vacio, then, and, etc


desliz0 a (salto 0)

desliz0 es una funcion de segundo orden, toma un vector y una expresion. Puede generar muchos clickers.
Desde un origen relativo, aplica la expresion del segundo parametro, generando un clicker. 
Luego, mueve el origen segun su primer parametro y vuelve a aplicar la expresion
Y sigue así hasta que la expresion sea falsa o se mueva fuera del tablero

desliz es como desliz0 pero se mueve antes de evaluar la expresion

deliz a (neg (captura 0))
siempre que captura se aplique a un espacio vacio va a devolver falso y no generar ningun clicker,
la negacion hace que desliz reciba verdadero. Esto hace que se siga buscando hasta llegar al borde
o encontrar una pieza enemiga
desliz devuelve falso si no obtuvo nunca una expresion verdadera


desliz (0,1) (estandar 0)
desliz0 (0,1) (vacio 0 then true(desliz (1,1) (estandar 0) and desliz (-1,1) (estandar 0))) 

true devuelve verdadero, and sirve para concadenar cosas sin ninguna restriccion
estas dos lineas describen el movimiento de una pieza que se mueve en una
linea vertical de la que salen lineas diagonales +






desliz a estandar 0
adentro de estandar hay un bool que se hace true despues de la primera captura para que de ahi
en adelante siempre se devuelva false. Supongo que esto significa que estandar esta
harcodeado, a menos que haga funciones de check de expresion tipo "se ha realizado una captura?",
pero parece mucho quilombo al pedo
Otra opcion sería simplemente no usar estandar aca, y hacerlo en dos lineas:
desliz a salto 0
deslizneg a (neg(captura 0))
esto hace lo esperado. Esta solucion me parece la mejor, porque no hace necesario harcordear
estandar, ni agregar cosas mas complejas



hop () ()

pasos a b : saltar a then b




cosas como reflejar se pueden usar desde el lenguaje para combinarse, pero su funcionamiento esta harcodeado


Habría una forma alternativa de plantear desliz que use como primer parametro una expresion tambien, si la
expresion es verdadera mueve el origen segun lo que la expresion retorne (habría que hacer retornos de
vectores en lugar de bools) y realizar lo que este en la segunda expresion. Supongo que así cosas
mucho mas anidadas quedarían mas limpias, aunque es un poco rebuscado

El fin del lenguaje es decidir que clickers generar, y darles su estructura a estos. No pueden usar como estructura
la oracion que los genera porque una oracion puede hacer muchos clickers. A demas el clicker no necesita volver
a hacer chequeos de valides, y que cada clicker tenga todo el algoritmo de interpretar oraciones es poco eficiente.
Cada clicker nomas tiene una lista de acciones a llevar a cabo al ser clickeado.




primero hacer un proyecto para hacer el sublenguaje, mas abstracto, despues aplicarlo a el juego

voy a necesitar un string de entrada
Va a haber una funcion recursiva de analisis, que arranca mirando la primera funcion del string

a( x )

mira a, segun una tabla ve que toma un parametro. Se llama a si misma en x, ve que es un parametro sin mas y lo
devuelve a la anterior, que construye a con su parametro integrado y termina.

b( x, a ( y ) )

mira b, segun una tabla tiene dos parametros. Llama analisis en cada uno, y con los resultados construye b




lo que viaja entre funciones es un puntero de objeto. Los objetos son los movimientos. Los movimientos son estructuras
que contienen como hacer chequeos, y que pasarle a sus clickers. Supongo que puedo usar herencia para abstrearlo mas,
y meter las coordenadas y todo en una misma bolsa.
No sé hasta que punto eso es buena idea.


un movimiento tiene coordenadas, que chequear en estas y a que clickers crear
un metamovimiento tiene coordenadas, que movimientos llamar y como

los metamovimientos hacen chequeos antes de usar un movimiento en alguna coordenada, y tambien pueden
hacer chequeos durante la generacion de clickers. El unico ejemplo que hay es castillo limitando repetir
Otro ejemplo donde sería util que el metamovimiento acceda a los clickers generados dentro de él es 
corteAlPaso agregando acciones a lo que se genere dentro de él
si termino haciendo todo con metamovimientos todas las acciones terminan teniendo forma de oracion,
podría sacar los parentesis


ver si puedo condensar mas haciendo cosas como mover({(1,0),(0,1),(-1,0),(0,-1)}) para describir todos los movimientos
en una linea en vez de 4. Sino no sale no sale, no importa
tambien sería util para aplicar un metamovimiento a muchos movimientos, mas que nada cuando se trata con el castillo,
para no tener que escribir todo el conjunto de coordenadas en cada linea



castillo tiene que ser un metamovimiento que controle que no salgan movimientos del castillo, un toque complejo


piezas que se mueven n turnos

piezas que tienen algunos movimientos que pueden hacer despues de moverse

las piezas ademas de movimientos tienen movimientos especiales, que supongo que estan por separado
y tambien tienen handlers. Un handler es el que se encarga de contener el bool de movimientoInicial y volverlo
falso despues de moverse. Otro handlers es el que se encarga de mover el campo de congelacion



repetirneg(captura v) 
Repetir mira si su contenido devuelve verdadero. En caso de hacerlo, crea un clicker usando el movimiento
que contiene, guarda las acciones en una lista, avanza la coordenada y mira devuelta si es verdadero. De serlo,
crea un clicker en su pos actual que contiene las acciones de la lista y ademas su contenido, vuelve a agrandar
la lista, avanza, repite.
Repetirneg mira si su contenido es falso, y de serlo, agrega un movimiento a la lista, avanza y repite. Ese agregar
movimiento harcodeado esta para que haga la animacion de avance. 






puede que no exista el movimiento leap, sea una combinacion de repetirneg capturar con algo que pase despues

repetirneg(captura(0,1)).mov(0,1)
sería el hop simple
para generarse el clicker se tienen que cumplir los dos. El clicker esta en la coordenada final, y contiene las dos acciones
repetirneg solo va a ser verdadero si encuentra un enemigo en algun punto

vacio(0,1).repetirneg(captura(0,1)).mov(0,1)
es para los que necesitan al menos un espacio libre

repetirneg(captura(0,1)).mov(0,1)
repetirneg(captura(0,1)).repetir(captura(0,1)).mov(0,1)
para saltar varios juntos

inicial( mov (0,2) . corteAlPaso (0,1) )
inicial mira que sea la primera vez que la pieza se mueve. Al construir la pieza
agrega el handler que mira eso.
Si es la primera vez, mov hace que se mire si su espacio este vacio. Si lo esta,
corteAlPaso mira si esta vacio. 
En caso de que si, se crea un clicker con las acciones de mov y corteAlPaso. 
Siempre que haya muchas acciones asi se hace esto, se toman las acciones de todas
y se aplican a un clicker cuya posicion sea la de la primera accion.
Por ahi es medio rebuscado, no sé. Es una mecanica que solo corteAlPaso va a usar,
creo. Mirar si hay otras que la usen y si hay algo mas comodo que englobe todo.
Por ahi va a ser mejor hacer que corteAlPaso sea un metamovimiento, asi todo sigue
la misma abstraccion 
inicial ( corteAlPaso (0,1) (mov (0,2) ) )
aunque puede que lo haga con el anterior, ya que una forma de poder hacer movimientos
que junten muchas acciones distintas en un mismo clicker va a ser necesario.
El clicker se situa en la ultima coordenada, no la primera. (tendria que poner corteAlPaso primero)
Se realizan todas las acciones en sus coordenadas respectivas en el orden que fueron escritas,
para hacer las animaciones


mult n [
 mov1
 mov2
]
mult toma un numero, y una lista de movimientos, y permite hacer alguno de estos movimientos n veces en un turno, o
combinaciones de estos
No se calculan n acciones directamente. Se calcula solo la primera, de ser verdadera genera un clicker con las acciones
inciales y con una accion especial. De elegir ese clicker, se efectuan las acciones pero no termina el turno. Ahora
se vuelven a calcular movimientos, los de mult, y se presentan. Tambien aparece un clicker extra en la posicion de
la pieza, indicando la opcion de no mover mas.

{captura(1,1).mover(1,1),
captura(-1,1).mover(-1,1)}
.forz[
captura(1,1).mover(1,1)
captura(-1,1).mover(-1,1)
...
]
cuando se ve forz se calculan los movimientos que esten antes. De ser verdaderos, se generan los clickers y se deja
una accion especial que contiene el movimiento dentro de forz.
Si se toca este clicker se efectuan las acciones pero no se termina el turno. Se calculan todos los movimientos de
forz. Si no hay ninguno verdadero se termina el turno. Si hay algunos, se presentan, y el jugador esta obligado a
elegir uno.
Habría que hacer un forz indeterminado y uno con rango, pero ahora no me acuerdo de ninguna pieza que use rango


rotar[mov(2,1) , mov(1,2)]
genera un clicker segun la primer movimiento de la lista, luego avanza haciendo lo mismo con el resto, ciclando. Como
un repetir, pero cambiando en cada paso
hay que hacer un rotarneg tambien


movimientos:
captura c - mira que en c haya un enemigo. Genera clicker capturar
mov c - mira que c este vacio. Genera clicker mover
corte al paso c - mira que c este vacio. Normalmente esta junto con otro clicker, agrega la accion del fantasma

meta:







1-inicial( mov (0,2) . corteAlPaso (0,1) )
2-inicial  mov (0,2) . corteAlPaso (0,1) 
3-inicial(u(mov(0,2),corteAlPaso(0,1)))

1-vacio(0,1).repetirneg(captura(0,1)).mov(0,1)
2-vacio (0,1) . repetirneg captura(0,1) . mov (0,1)  <-ya hay conflictos de pertenecia aca, descartar este
3-u(vacio(0,1),u(repetirneg(captura(0,1)),mov(0,1))) <-este es el mas facil de implementar, pero queda re feo

inicial( mov (0,2) . corteAlPaso (0,1) )
inicial podría ser unario, total es un check unico
inicial.mov(0,2).corteAlPaso(0,1)

analisis encuentra inicial. No tiene parametros, asi que lo genera. Acá terminaría y devolvería eso de no ser porque
se encuentra un punto. 
Genera la unitoria de lo que tiene hasta ahora y lo que viene despues.
Osea, como ultimo paso en vez de devolver inicial devuelve unitoria(inicial,analisis("mov(0,2).corteAlPaso(0,1)"))
ahora toma mov. Segun la tabla toma una coordenada, la toma y genera mov con eso
(o por ahi genera mov, y mov en su constructor toma la coordenada y avanza el iterador)
la funcion termina devolviendo unitoria(mov(0,2),analisis("corteAlPaso(0,1)"))
genera corteAlPaso, lo devuelve
el resultado final, en objetal, es unitoria(inicial,unitoria(mov(0,2),corteAlPaso(0,1)))

unitoria es un metamovimiento, toma dos movimientos. Lo unico que hace es correr uno, despues el otro.
devuelve verdadero si los dos dan verdadero

repetirneg(captura(0,1)).mov(0,1)
repetirneg es un metamovimiento que tiene como unico parametro un movimiento, asi que analiza directamente todo
lo que tenga adentro. Como hay un punto despues, hace el procedimiento de unitoria, queda 
unitoria(repetirneg(analisis("captura(0,1)")),analisis("mov(0,1)")
entonces
unitoria(repetirneg(captura(0,1)),mov(0,1)) en objetal


entonces analisis es una funcion que toma un string y devuelve la estructura de movimientos que describe
es un poco pesado pasar los parametros por afuera, pero meter la funcion analisis adentro de cada movimiento
es ineficiente y cosas como la unitoria terminan siendo mas complejas


multimovimientos
un movimiento simple que puede ser seguido por otro se puede expresar usando un operador >
mover(0,1)>mover(0,1)
esto se diferencia de mover(0,1){,.mover(0,1)} solo en que se hace un corte. primero se calculan
los clickers de la izquierda, y cuando se elija alguno se calculan los de la derecha.
El jugador puede volver a tocar la pieza si no quiere volver a moverse, esto se genera desde el 
metamovimiento.
solo se hace un chequeo de validez de izquierda
Esto es para el jugador. Para la IA es exactamente igual a la otra expresion.

conversion de la IA
a>{b,c}>{d,e} => a{,.b,.c}{,.d,.e} => a , a.b , a.c , a.d , a.e , a.b.d , a.b.e , a.c.d , a.c.e
aca hay un problema. a.d y a.e no deberían estar, pero por como estan las reglas ahora estan
habría que poner una regla mas: en el caso de elegir el camino vacio, no seguir buscando
-
el camino vacio no debería estar, ya que representa moverse y ya esta, no moverse y elegir dejar de moverse.
Tendría que poner en lugar de vacio un  movimiento null, y meter esta propiedad de que nada puede ir despues
en él
tampoco me convence la notacion de llaves, porque estas terminarian creando duplas de null con cada elemento que tengan,
lo que es redundante. 

Las llaves no van a funcionar, porque a>{b,c} => a>b ; a>c por como funcionan las llaves. Cuando se lea a se va a sacar b,
no se va a buscar en mas lineas para ver si hay un c

debería haber una forma de hacer que algo se repita n veces, por ejemplo
a>[3]b = a>b>b>b


tambien habría que agregar un operador de seguidilla obligatoria # 
a#{b,c} => 

estos mecanismos son esteticos y pueden ser utiles para evitar que se haga un quilombo de clickers, pero a la
IA la acomplejan al pedo. Para la IA es mas util tener todos los movimientos planos. Supongo que estos movimientos
se convierten distinto para las piezas de la IA, desde el principio.

----------
OTRA FORMA, que es basicamente lo mismo que la otra pero se ve mas limpia y sigue la misma notacion que otros metamovimientos
(usa la funcion parentesis para separar)
a.op(b)
o
a>(b)


a>b
a>c
se lee la primera linea, se genera el clicker a que despues tira b. Se lee la segunda linea, se superponen clickers.
Se podría hacer un caso especial para esta superposicion que fusione la salida.
pero es mucho quilombo, creo que sería mas simple dejar como regla que todo debe estar en una sola linea

a>(b v c)
es necesario entonces ligar b y c de alguna forma, que de uno o el otro, como las llaves, pero no de forma lexica.
v es un operador que hace eso, junta b y c en un puntero union.
Ahora queda todo escrito en una sola linea, no hay redundancia. 
Y lo mejor de todo es que entonces no va a haber una diferencia importante entre el jugador y la IA. Para el jugador
va a haber un corte de control.
Para la IA es un metamovimiento mas que genera muchos movimientos, y que se puede recorrer eficientemente porque es un arbol




Una forma de tratar la superposicion de clicker distintos e incomparables es hacer que estos vayan cambiando una vez por
segundo. Es stylish, y es mucho mas facil de hacer que crear un menu









