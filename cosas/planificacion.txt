
En muchos lugares uso vectores para pasar datos tecnicos. Por ahí me conviene meter un string 
por default vacio para pasar esto y dejar los numeros limpios?


En memoria dinamica esta la matriz y un vector con las plantillas de las piezas
Estados:
Pantalla inicial
Selector de modo. Modo normal, editor, algunos modos prehechos. Cada boton modifica la matriz
Proper, el juego. Toma la matriz, y crea las piezas comparando los numeros que estan ahi con el vector de plantillas
el editor de mapa, para crear matrices
el editor de fichas, para agregar plantillas al vector de plantillas



Los botones pasan initializer lists a proper, que construye su matriz a partir de eso
El editor necesita crear una matriz con memoria dinamica, y va a usar un puntero para pasarsela
entre sus dos estados. Este va a acceder a proper por otro constructor, que toma ese puntero,
crea la matriz y despues lo delete.  

Proper construye las plantillas basicas al arrancar. El editor tiene un vector dinamico donde guarda 
plantillas adicionales. Se lo pasa al constructor de proper, que agrega estas plantillas a su 
vector y despues delete[] (supongo)




La matriz de proper es de Pieza* puedo usar el puntero nulo para indicar espacio vacio,
y estoy literalmente señalando las piezas sin necesidad de hacer un pasaje por indices o algo así
No hay un vector de piezas, para hacer los calculos y dibujar se recorre la matriz. Creo que va a
terminar siendo mas comodo. Por eso tambien, las piezas no van a saber su posicion

La unica diferencia entre las piezas y las plantillas es que las piezas tienen la imagen cargada,
y son manipuladas, puede que despues les agregue funciones especiales para la IA y el input.
La plantilla tiene un par de funciones tecnicas, y podría ser integrada en el constructor de
proper y dejar de existir, pero asi como esta hace que el constructor quede mas simple, y
hace mucho mas comodo el pasaje de datos de piezas creadas en el editor. Esto ultimo es suficiente
motivo para dejarlo asi






Lo malo de agregar muchas cosas es que el codigo va a perder elegancia. A menos que mantenga
todo limpio con herencias, igual aun asi se va a enquilombar todo

ver si agregar el anti rey, bastante opcional
el asesino es una pieza medio transparente, sabiendo que la maquina tiene
tambien una totalmente invisible dando vueltas. Tarde un turno en revelarse y solo puede
atacar revelado. Ocupa un espacio en el mapa. La deteccion de enemigos de las piezas
que se deslizan no lo ven, pero la pieza se lo come y queda ahi. (el input lo ignora,
las piezas de desliz hacen su movimiento paso por paso y van mirando que no haya nada)
No estoy muy seguro de que pasa si una pieza se mueve a un lugar donde este, pero es movimiento
sea de no ataque. Podrían capturarse los dos, ganar el asesino o ganar la pieza 


antes de avanzar expandir el tablero a nxm y agregar soporte necesario para todas las piezas
de https://en.wikipedia.org/wiki/Fairy_chess_piece#Notable_examples , incluso las jodidas
como la dama, el cañon y el guason
Las piezas o van a tener hijas o van a tener muchos datos complejos que no necesariamente usen
pueden empezar fuera del tablero y nacer a partir de una condicion (codigo que se lee en cada turno de no nacido)



A demas de implementarlo habría que ver como puede interpretarlo la IA, y como funcionaria con el sistema
de movimientos. Supongo que en el caso de las piezas
que hacen algo al morir o necesitan una condicion para nacer se va a necesitar codigo especifico que valore
esas cosas por separado














cada plantilla tiene una id, un tipo, un vector de vectores y una prioridad
la matriz esta compuesta de ids, dice que plantilla usar de molde para la pieza en esa posicion
Tambien sirve para identificar al peon, torre y rey para casos especiales.

el tipo sirve para saber si la pieza tiene movimiento de tipo salto o continuo
las de salto solo pueden moverse a las coordenadas relativas de su vector de movimiento
el continuo puede moverse cuantas veces quiera, siempre reeligiendo la misma coordenada

el vector de vectores guarda las coordenadas relativas a las que se puede mover una pieza.
Hay uno para movimiento comun, y otro para movimiento de captura. En todas las piezas
menos el peon son el mismo. 
se usa para limitar al jugador a lugares de movimiento valido, y la IA la usa para calcular
sus movimientos y los enemigos.
La funcion de elipsis agrega a los dos vectores, la del peon hacerla manualmente, 
son 2 coordenadas a dos vectores nomas
En el editor por ahi se agrega manualmente cada vez que tocas un cuadrante, no sé
Algo a notar es que todas las piezas tienen movimiento simetrico en el eje vertical.
Por lo que las coordenadas deberían ser solo de un lado, del otro se marcan automaticamente
Que el movimiento y ataque sean simetricos es una restriccion a las piezas editadas tambien.
Una pieza que se mueve en un solo sentido no tiene mucho sentido

la prioridad la usa la IA para decidir si vale la pena sacrificar piezas, comparaciones asi
el peon incrementa su prioridad conforme se acerca a la linea enemiga

con la plantilla se crean las piezas, que toman todos los datos de la plantilla,
y a demas tienen posicion y bando.
El bando es 1 o -1. El bando multiplica las coordenadas verticales de movimiento posible,
para hacer que los peones de uno suban y los del otro bajen.
Tambien hay un bool que indica si la pieza es reclamable o no. Las unicas no reclamables
son el rey, el peon y el fantasma
Tambien, en la matriz, se guardan las piezas de un bando como positivas y las del otro como negativas.
El color de las piezas no esta asociado al bando, se elige al azar al comenzar la partida.
Tambien quien mueve primero se elige al azar (o esta asociado al color), en todos los casos.
Si quiero que en algun mapa mueva primero la maquina o el jugador puedo meter un int en algun lado




el rey tiene una prioridad practicamente infinita, si muere se termina la partida, y puede
hacer enroque. Si esta seleccionado aparece un boton de rendicion

el peon no ataca en el mismo lugar que mueve, en su primer turno puede moverse el doble
,esta la regla de corte al paso, su prioridad aumenta conforme avanza y al llegar a la linea
enemiga se puede reemplazar por otra pieza
tiene el chequeo de su posicion para aumentar su prioridad,
y tiene un bool de saltoInicial
Cuando el peon hace un salto inicial, crea un peon fantasma en la otra posicion

Este peon fantasma es una pieza especial. Existe solo durante el turno enemigo inmediato, 
despues se autodestruye 
--
cuando se cree el peon fantasma se va guardar una posicion en el control del juego,
y cuando se termine el turno enemigo se va a buscar el peon y se lo va a borrar.

Se mueve el peon dos casilleros, se crea el fantasma
se agrega la posicion al control

se mueve el enemigo
 si come el fantasma, se saca del control y se captura al peon
 si no come al fantasma, el control elimina al peon al finalizar el turno
 si crea un nuevo fantasma, el control elimina al primero y luego agrega al segundo

Osea, se elimina lo que este en la posicion de control al finalizar un turno donde no se 
creó un fantasma o antes de crear un nuevo fantasma
Si no hay ningun fantasma la posicion guarda algo para signalizar que la ignoren, tipo -1,-1
--
Es una pieza para poder ser interpretada por la IA y el input como tal sin necesidad de hacer 
casos especiales

moved arranca siendo false, si es false y hay un movimiento, y se trata de una pieza que la use (peon, rey, torre)
se vuelve true y se registra esto como una extension de turno. (en caso de enroque no se hacen mas extensiones,
queda registrado con eso) la extension tiene la pos de la pieza y algun numero especial 
mientras sea true se ignora. 
cuando se regresa y se llega a la extension se vuelve false.
En el caso de los peones se podría deducir si se movieron o no, lo que lo caga es una torre o un rey yendo back and forte





La partida termina en empate si se repiten los mismos movimientos 3 veces o no se come ninguna
pieza ni se mueve un peon en los ultimos 30 turnos

Podría usar algun id para peones que no arrancan con el doble avance, que sería una pieza distinta
(no puede ser un peon que arranque con ese bool en false porque al reiniciarse la partida no hay
forma de hacer que no se reponga)

Hay que tener en cuenta el caso de que haya 2 reyes, la partida termina cuando ambos mueren
Si no hay ninguno, la partida termina cuando alguien se quede sin piezas (supongo que si
quedan dos alfiles que no se pueden tocar hay que esperar a tablas, es un caso muy extremo.
Y si hago algo para eso estaría ignorando los casos infinitos de piezas inventadas)

En el primer turno la IA hace unos rolls para ver con que jugada arrancar, asi no es siempre
lo mismo. No sé si hay que meter mano negra para hacer que sea conciente del enroque
o va a ser algo que haga espontaneamente cuando pueda, lo mismo con el movimiento inicial

Cuando la maquina esta perdiendo las tiles del fondo empiezan a cambiar aleatoriamente
cuando se regresa las tiles tambien se mueven aleatoriamente.
Los desencadenantes de que pase eso se calculan en ambas direcciones



Se guardan todos las instancias de juego, para poder volver hacia atras. Tambien para
poder implementar la regla de que un movimiento no puede repetirse 3 veces y eso
Al terminar una partida hay un boton de rejugar. Al apretarlo pasa toda la partida 
anterior en reversa. Es una animacion que queda bien y saca la necesidad de que se recuerde
la posicion inicial de cada partida
Cada paso que se guarda esta compuesto por dos posiciones, de donde a donde se mueve una
pieza, y tambien de un dato que guarda si generar o no una pieza en la posicion de la que
se mueve (en direccion normal sería que la pieza capturó a otra que estaba ahi)
Supongo que no es necesario guardar cual es la pieza que se mueve, se puede ver en el momento
teniendo la posicion en la que se movió. El dato de la pieza para generar sería un int con
la id, o -1 si no hay nadie
Hay un bool para casos especiales que indica que un movimiento es una extension de un movimiento
anterior, y debería ser representado como uno para la regresion (al volver hacia atras se vuelve
la extension y el turno, no se puede volver a la mitad)
La extension sirve para casos especiales donde se van a interpretar los datos de forma especifica:
-en el enroque, el turno es el rey moviendose a su posicion y la extension es la torre moviendose a la suya
-en la asignacion, el turno es el peon avanzando a la ultima linea (donde el id es el de siempre, porque
puede haber comido o no una pieza al avanzar), y la extension, donde el id es la pieza a la que se cambió
y el movimiento es un numero especifico que aclara que pasó una asignacion. Cuando se vaya para atras y 
se vea este numero, se va a cambiar la pieza actual por un peon y despues se va a leer el turno como si nada
-el peon fantasma se crea desde el codigo del peon. Despues del turno enemigo se agrega a si mismo (desde su control) a
los movimientos al autodestruirse. Entonces, si el enemigo regresa el peon va a renacer.
En caso de que el enemigo capture al fantasma este ultimo paso no pasa. En el caso de captura, en reversa, al registrarse
que se capturó un fantasma se va a generar un peon arriba o abajo dependiendo del bando


Podría haber kakeos si se acumulan varias extensiones?


agregar el modo de juego donde las piezas capturadas por alguien pueden ser traidas devuelta al juego, despromocionadas
(no se pueden poner en un bloque de promocion), con el bando cambiado. Hay un ajedrez que se juega asi, y el shogi 
lo tiene por defecto
Voy a necesitar que todas las piezas tengan un puntero a la pieza de la que salieron, en caso de que sean promocionables


hacer un modo IA vs IA
hacer un modo donde la IA tenga una chance de 1/3 de tener doble turno
hacer un modo donde las piezas son seleccionadas al azar


estaría bueno que haya piezas de desliz y salto a la vez. Por ejemplo, una que pueda
delisarse verticalmente y solo pegar saltos a los costados

Por ahi ampliarlo para que se pueda jugar al shogi tambien?
Habría que hacer piezas de desliz y salto a la vez, y un trigger al llegar al final 
para el editor, medio al pedo igual

