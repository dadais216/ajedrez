
manejar tamaño en alocacion de operadores para no hacer lo que hago ahora, sino alocar algo mas chico e ir creciendo

----

actualholder.h debería ser un int tambien, si se realoca durante la mitad de un movimiento vuela todo a la mierda. Si hay problemas de eficiencia podría verse de reemplazar todos los punteros globales cuando se realoca

----

encapsulado no se grafica bien porque el inRange se calcula mal. Se debería calcular segun cada operador en caso de que no tenga sig, depende de cada tamaño

----

puede que prohiba tener cadenas de movimientos en exc, no me termina de cerrar y es raro

creo que hay un problema tambien, si se tiene
exc  
    desliz exc A or B c end end D c 
    or E end 

pasa algo que no es muy claro
-si se va por el camino B+A* D y D falla, se toma esta rama porque tuvo clickers. Este es el comportamiento raro que acepto
-si se va por el camino A+ D y D falla, tambien se toma esta rama aunque NO se creo ningun clicker

actualmente valor solo significa algo para normal (creo)
valorCadena significa que PUEDE haber algo adentro en la cadena
valorFinal asegura que toda la cadena es valida

valorCadena es suficiente para cargar clickers, pero no como logica para exc. Creo que en los otros operadores no importa pero puede que tambien
en este caso valorCadena significa "en esta cadena hay un clicker valido", lo que es un concepto mas especifico.

desliz tomaría su valorCadena de si se le propaga algo internamente Y si le viene algo despues. (actualmente tiene hasClick que cumple mas o menos esa funcion y supongo que por eso lo invente)
otros operadores tambien van a tener esa capacidad de ser propagados por cosas internas ademas de lo que viene despues

puede ser que baste con propagar valorCadena solo cuando un makeClick se hace valido? Puede que haciendo esto tampoco necesite hasClick, no sé

----

goto no se grafica por algun motivo?

----

growin tenía clicker roto, creo que lo rompi en este cambio asi que lo arregle

emperador anda como antes pero habría que mirar bien que onda


---

ver lo de construir antes en desliz, creo que desopt tambien?

---

hacer que exc tenga la caja antes 

---

en desopt puedo construir todo antes, asi no tengo que manejar esta logica de si existe el bloque o no. Siempre van a ser los mismos movholders, la diferencia esta en como se enlazan nomas. Que quede un estado interno viejo no debería ser un problema, por ejemplo en exc pasa y no rompe nada, cuando se regenera se pisa todo.
Cuando genera construye, marcando el proximo iterador en 0 cuando el movimiento es invalido.
Cuando reacciona solo construye en espacios nuevos, lo que fue construido se reutiliza.

es confuso que el codigo de generarNodo no se use en generar, solo en reaccion, debería tener un nombre mas especifico

---

hay cosas que se pueden mover al lado de pieza, como offsets y eso. Mover todo lo posible
cambiar sig por centinela? medio experimental. Creo que no igual porque sig no esta al final de los operadores con tamaño variable

el puntero a la tabla virtual podría estar en operador, no hay motivos para que este del lado de movholder
sig podría ser un offset en operador, base tambien. 
Lo unico de movholder serían los bools porque algunos se necesitan y los otros no molestan.

en normalH op por ahora queda, pero podría probar moverlo al trigger (traería normal + normalh)
el varray queda pero las estructuras de control estan en operador, en normalh esta solo el contenido
pos queda


en desliz creo que podía sacar cantElems si construyo todo desde el principio
beg podría ser un offset 
f queda

exc manejar el varray como en normalh, actualBranch queda

isol creo que puedo delegar todo al operador? tiene un size que creo que esta al pedo, despues un offset

desopt tiene solo el dinamclusterhead, que queda.

como ahora voy a recorrer el arbol de operadores voy a tener que mantener un estado interno que antes estaba en movholders, pero creo que no sería demasiado complejo, creo que es practicamente lo mismo


---

cambiar el sistema de triggers, en vez de tener un puntero a normal que tiene una base, se puede tener en cada normal 2 ints, que indiquen holder y numero de movimiento (ocuparia lo mismo). Si muevo memLocal al lado de operador ya no hay motivo para tener bases. Creo que los otros operadores que usan bases podrían usar una variable global y listo.
En un momento considere no guardar informacion en trigger y buscar el movimiento y holder haciendo comparaciones de rango, pero necesito algo contra lo que comparar, asi que algo de informacion voy a tener que pasar, y ya que hago eso pongo todos los datos y listo. Son 2 ints nomas

Sino se podría probar de tener solo la normal y buscar el holder por rango, dejando que cada trigger mida 8 bites? no sé si importe mucho porque con segundo orden puede que meta mas informacion en el trigger?

---

considerar un desopt y desliz que realoquen de necesitarlo. Puede que el golpe de eficiencia en la primera iteracion valga el tener una memoria mas ajustada, y hace que el programa no crashee por error de usuario lo que es mucho mas amigable. El tamaño se puede poner manualmente igual, pero va a haber un if (que si no se usa es practicamente gratis) para crecer si se necesita.

---

renombrar fail a break
lo que hace fail/break es retornar falso pero dejando las acciones que estaban antes. Sería equivalente a <normal> c mcmp 1 2, con la diferencia de que esto otro hace un clicker y break no. Es util para romper desopts/deslizs cuando hay una condicion positiva pero no se necesita iterar mas

----

en algun momento rompi el tema del click implicito e isols, por ejemplo el peon no hace lo que deberia

----

w desliz dasda end hace una normal en w, estaría bueno que no pase? implicaria ponerle un desplazamiento a cada operador, no sé

----

Cuando se tiene un desliz con 2 triggers, se activa el primero, se genera sobre el segundo y este nunca se vuelve a mirar.
Si el primero no se encuentra es obvio que el segundo, de encontrarse en el desliz, tampoco se va a encontrar. Se busca más alla. Por ahi vale la pena chequear si el segundo esta mas allá (creo que podrían fallar unos asserts sino)
el caso particular del emperador es un poco mas complejo. es un desliz con un isol adentro, cuando el trigger adentro del isol se active y isol lo borre, desliz va a darse cuenta de que el trigger que amago a tirar no activo nada. Si hay un segundo trigger debería intentar activarlo, y lo hace, porque este puede pertener a una proxima iteracion. El problema esta en que ese trigger puede tambien pertenecer a la misma iteracion que el primero, y generar calculos redudantes. No sé si vale la pena arreglarlo, pero la solucion a esto es hacer que isol no solo borre el trigger que activó, pero todos los que esten adentro de su rango. Lo mismo con desliz y su rango invalido.

se podrían filtrar las normales que le pertenecen a un operador para que este las maneje. En la gran mayoria de los casos no es relevante, porque se pasa a generar cuando se encuentre la primera, pero podría ser importante en los casos de normales innaccesibles, porque se tiene que volver a un bucle for bastante atras reaccionando por movholders al pedo. El costo de filtrar no es muy alto pero existe, por eso quiero probar esto aparte para ver que pasa. Si funciona lo dejaria porque hace al sistema más limpio.
Por ejemplo deslices anidados, el desliz exterior va a pasarle las normales de a una en lugar de pasarle todas las que le pertenecen, lo que en caso de que la primera sea innacesible va a causar un rebote entre los 2 que se podría saltar. 
Para meter un mecanismo como este el desliz interior, despues de borrar las nhs innacesibles, en vez de saltar al inicio deberia saltar al bucle for exterior, lo que implica tener un stack de jmpbufs. Se hace
esto me permite sacar el for del reaccionar de normal

el desordenamiento de desopt rompe algunas cosas. Por ejemplo, hay un trigger en la segunda iteracion de la base y otro en una rama de la primera iteracion. Se va a procesar la primera iteracion, se va a ir a sus ramas y se va a saltar a la que tiene el segundo trigger. El primer trigger sigue en la lista, porque esta antes en memoria, aunque se procese despues. Esto rompe varios operadores.
Hay 2 formas de solucionarlo, una es cambiar desopt para que reserve toda su memoria de forma dinamica, y de forma depth search, no poniendo bloques de toda la iteraciones de un nodo de una. La otra es, si hago filtrado, solo pasarle a un nodo las normales que estan más adelante que su base en memoria. Esto asegura que recibe las que le pertenecen y las que potencialmente pertenecen a sus ramas. La segunda opcion me parece mas razonable, incluso si decido no filtrar otras cosas. La primera requiere rehacer todo el movholder, porque tiene una forma de reserva distinta lo que sería más lento porque no tiene parte estatica, y, mas importante, una regeneracion implica volver a generar todos los nodos que vengan despues en la recorrida del arbol, no solo lo que salgan del nodo activado

----

medir tiempo de carga

----

reaccionar vs directo:
en una primera instancia necesito generar todos los movimientos, esto se hace en los 2 modelos, en reaccionar se hace todo inicialmente, en el directo se hace justo antes de moverse. El directo es mas rapido porque no necesita poner triggers, y no necesita guardar estados intermedios. Asumo que la carga cuesta lo mismo en los dos, porque aunque en reaccionar sea un proceso aparte, en directo tambien se hace y el tema de pausar la generacion y retomar (o generar de 0 devuelta) despues puede tener un costo cuando una generacion hace varios movimientos.
En la segunda iteracion se necesita hacer lo mismo, y aca esta la ventaja. En reaccionar solo se necesita generar la pieza que se movio y piezas que hayan sido afectadas por esta para llegar a un estado donde todos los movimientos estan a una carga de distancia. En directo se tiene que generar todo. Estoy bastante convencido que el costo de poner triggers y reaccionar a estos le gana a tener que generar todas las piezas devuelta, al menos en la mayoria de los casos.

Y hay que pensar que para la IA voy a tener un arbol de movimientos de n turnos, en directo necesito generar esos n turnos cada vez, en reaccionar solo generaria la rama de la pieza que efectuó el movimiento, y los que reaccionen de esta. Acá esta la mayor ganancia, y va a ser mayor mientras mas turnos. La mayoría de las piezas se mantendrían inmutadas, solo se generarian nuevas ramas para las piezas que de repente tengan mas movimientos posibles, o menos, donde se invalidarian ramas nomas. Y estas reacciones no se limitan al primer movimiento de cada pieza, puede reaccionar un movimiento 3 turnos en el futuro tambien. Tengo que tener cuidado de hacer el procesado en orden e ignorar movimientos futuros que terminen siendo invalidados o duplicados. Creo que si me convenzo de esto es mejor no valdría la pena testear lo otro. 

Cuando se efectua un movimiento en reaccionar simplemente se toma la rama corresponiente como la actual, y se calcula una nueva ultima iteracion. En directo en principio se tiene que hacer todo devuelta porque no se guarda estado

Otra ventaja de tener modo reaccionar es que funciones de puntaje que evaluen cosas complicadas (como cantidad de casilleros amenazados) serian mas faciles de hacer, creo

En principio reaccionar parece mejor pero para funcionar necesita tener que guardar estado por cada normal y tener triggers. Tengo miedo de que esto termine siendo mas costoso que las generaciones que ahorra. La version directa funciona solo usando operadores, no hay movholders ni sistema de triggers (se mantiene algo de memoria temporal mientras se hace el movimiento). Esta bien que con movimientos mas complejos rehacer todo tiene un costo, pero los movimientos complejos tienden a reaccionar de forma temprana y recalcular una parte importante, asi que puede que no cambie mucho.

Me parece que el mejor curso de accion es seguir con reaccion hasta tener el rey y piezas de ese nivel de complejidad, hacer varios test y despues rehacer el ajedrez en modo directo para probarlo. El modo directo no me debería llevar demasiado tiempo, es volar las reacciones y meter la carga en la generacion, que generaria una version de normalholder que solo tiene acciones y posicion. El test que se haría para comparar es hacer un movimiento y llegar a un estado donde se tengan todos los movimientos del tablero, lo que simularia hacer un paso en un arbol minimax.
- en reaccion, hacer un movimiento y generar la pieza y realizar las reacciones, despues cargar todos los movimientos.
- en directo, hacer un movimiento y generar todas las piezas.

si resulta que reaccion es mejor sigo como esta. Sino bueno, me cambio al otro que es mas simple. Un poco de bronca por la falacia de costo invertido pero bueno, este otro sistema tiene la ventaja de que es mas simple. Si hubiera ido por ese primero, y hubiera pensado en el otro, tambien tendría dudas de cual es mejor.

necesitaria investigar bien alpha beta prunning y otras cosas que usan algoritmos de ajedrez, puede ser que le este pifiando horriblemente

----

algo que hace al lenguaje complejo es que las condiciones aplican solo al estado del tablero actual, lo que puede hacer algunas cosas confusas. En el caso de la dama la complejidad se dispara por eso. Podría considerar tener un modelo donde apliquen las acciones cuando se calcula, y despues se deshacen. La idea de usar snapshots no funcionaria ni en pedo porque es demasiado costosa, todavia mas si se tiene en cuenta que los rollbacks no se hacen solo al final del movimiento pero en varias partes en caso de isols y demases. La otra opcion es hacer todas las acciones reversibles. Supongo que duplicaria el costo de cualquier movimiento pero puede que valga la pena, no sé. Guardar la memoria local en cada paso sigue siendo necesario, asi que no simplifica eso, suponiendo que tenga el modelo de reaccion. 

----

cortar regeneracion si la normal que disparó el trigger no cambia de estado (falso->falso o verdadero->verdadero)
Para hacer esto necesito el mecanismo de longjmp para poder huir. Si hay mas de un trigger se vuelve a modo busqueda, no pasa nada
Esto no andaria si la normal depende de memoria global/tile y hace un pasaje a memoria local, ya que aunque mantenga su estado de validez puede propagar algo distinto. En principio que la memoria sea reseteable o no no cambia esto. 
Para manejar esto debería haber un bit "pasa memoria global a local" en cada normalH. Tambien podría haber un bit "trigger de memoria global", para no activar en caso de que el trigger por otra cosa, pero creo que por ahora no vale agregar un campo nuevo a trigger solo por eso.

----

ver que el manejo de ventana y eso no tenga un efecto en la medicion de performance. Estoy casi seguro de que no igual.

----

ver si pasarme a sdl. No sé si me aportaría algo mas alla de tener codigo no objetos. Si es solo eso como que no vale el esfuerzo

----

hacer que los colores se saturen menos. No importa si el sistema es lento porque solo corre cuando se dibuja. 
Creo que lo que quiero hacer es promediar los colores, pero desfasar un poco el divisor para que colores iguales se aumenten un poco
Tendria un array de colores, donde los voy sumando y actualizando el contador. Al final de todo hago un bucle for y los dibujo

----

mirar test growin, pone clickers donde no deberia y siguen generando despues del isol

----

hacer memcpys sobre el buffer, para evitar fragmentacion interna?
no sé si esto rompe la generalidad de los getters, y los getters son lo que mas lo usa. Ver

se avanzaria por (sizeof(struct) + sizeof(pointer) - 1)/sizeof(pointer)

----


Creo que no voy a hacer test que verifiquen que las cosas anden bien, los test de velocidad ya me dicen si alguien rompe, y si algo anda distinto se deberia ver en el tiempo. 

Los test que verifiquen cosas se podrían hacer teniendo condiciones y acciones especiales, que miren cosas como cantidad de triggers, etc. La verdad es que es medio interesante y se podría hacer, que sé yo.

----



codigo no ligado a pieza que corre todos los turnos. Con eso se puede implementar corte al paso, haciendo que el peon inicial al moverse ponga un peon tecnico que es eliminado por el codigo general (al que se le pasa la pos del peon), de paso hacer una pieza que tire un orbe que se mueve una tile cada turno.
Tambien implementa piezas que reaccionen a turnos actualizando una memoria global todos los turnos. Tambien maneja tener turnos como que avanza 1 por jugador o 1 por ronda.

----

hay que ver el tema de la comunicacion entre isols y deslizs

Cuando se reacciona en isol y se genera algo internamente, desliz NO debería seguir regenerando, debería cortar ahí.
A menos que sea la version de muchas normales, en ese caso debería consumir la que usó isol y seguir.
A menos que isol diga que desliz genere, lo que pasaria en caso de usar memoria no reseteable


En el caso de desopt, si la memoria no es reseteable, no solo tengo que regenerar los nodos que salgan del que se activo pero tambien ramas que estaban siguientes en la generacion inicial, lo que implica otra forma de recorrer

-

El problema que hay es que isol no puede manejar memoria no reseteable, la diferencia esta en la reaccion.

Isol comun al reaccionar y activarse solo genera codigo interno, por lo que no necesita restaurar nada despues. El codigo interno se encarga de tener la informacion y hacer sus cosas.
Ahora con memoria no reseteable un isol tiene potencial de afectar cosas que esten despues de si, por lo que pierde esta propiedad de estar aislado. Es fundamentalmente distinto, al reaccionar y activarse necesita seguir generando. Y el tema es que para seguir generando y mantenerse consistente necesita restaurar la memoria antes de haber generado, y para eso la tiene que guardar.

Puedo hacer una segunda version de isol que maneje esto, pero no sé si vale la pena porque es re niche. Lo mismo con desopt. Pero bueno, por ahora es la unica forma de poder restaurar posicion, memoria local y buffer de accion ademas podiendo propagar informacion para adelante. Por ahí hay una forma distinta de hacer eso?

revisar los otros planteos que tenia, igual ir por esto no es tan malo. El nuevo isol reutiliza casi todo el codigo de isol, nomas que la reaccion es distinta. Y tiene tamaño variable. Lo que me molesta es que es un re asco por algo que se usa poco, pero si no se me ocurre otra cosa ya fue.

Por ahi tener funciones generateOnFirstNormal en vez de guardar memoria variable 

----



medir tiempo de carga tambien, porque tiene un impacto en la IA. Seria el tiempo que tarda en cargar todos los clickers, promediado.

----

nunca testie el sistema viejo de triggers, confio en que es peor pero bueno, fue un cambio que hice antes de medir.
El sistema era tener un vector por cada tile y memoria.

----

un modelo alternativo a los movholders seria usar solo normales, estas teniendo un puntero para avanzar en el caso bueno y otro para caso malo. Desliz y exc se pueden implementar con eso, isol por ahi tambien pero con algun chequeo mas, me imagino que desopt tambien. Estaria reemplazando el polimorfismo por un super coso con un monton de chequeos, lo que tiene la ventaja de que en la reaccion no necesito recorrer toda la estructura ni trepar el stack, puedo saltar directamente al lugar del trigger. Que todos los operadores tengan el mismo tamaño, porque son todas normales, tiene algunas ventajas supongo.
Un tema son los falsos positivos. Recorrer la estructura buscando triggers no solo cumplia la funcion de armar la estructura en el stack, tambien cumplia la funcion de no activar ramas falsas, porque nunca se llega a estas. Lo que se puede hacer para evitar esto es trashear las ramas falsas durante la generacion, y despues preguntar por eso. Hace recorridas extras durante la generacion pero evita la reaccion, podría servir o no que sé yo

Otra alternativa es que cada operador tenga un puntero hacia su padre, y armar los operadores a la inversa. Creo que habia descartado esto antes, pero no me acuerdo por que. Debe ser porque tiene el probelma de los falsos positivos, y para solucionarlo tengo que hacer algo bastante igual a lo que hago con armar el arbol, y mas feo porque no tengo el stack bien

---

el sistema para no copiar todo el bloque de memoria es que cada movimiento sepa el rango de memoria de movimiento que usa, y para la memoria global, triggers de tile guardar un array de bits que corresponda a sectores de memoria. Cuando se accede se setea el bit, al final se recorre y se copia los bits en 1

---


movimiento (wasd) antes de operador hace normal al pedo

---

podria usar menos cosas globales, queda mas lindo a veces. Ahora puedo ver si tiene un impacto o no

---

barray que interprete lo que tiene despues como begptr podria servir, medio especifico igual

---

pensar como hacer el tema de movimientos que dependen de bando. Si termino yendo por la idea de generar una version para cada uno por el tema de w/s, no estaria mal agregar un macro BANDO( | ) que tome que iria para cada uno y listo. w/s se podría implementar con eso tambien, aunque no sé si me gusta la idea de spamear macros porque es algo mas lento y cambian el orden de los movimientos. Podría solucionar lo segundo

---

hacer que los macros no alteren el orden, es una optimizacion al pedo y molesta

---


probar si hacer todas las funciones estaticas hace mas rapida la compilacion, deberia

---

checkSelf

----

los operadores quedarian aparte del estado de juego porque son constantes, se copian cuando se guarda pero no cuando se replica para la ia. En el editor queda medio raro porque se generan justo antes de usarse, pero no deberia haber problema

----

las acciones en condiciones, que creo que voy a limitar a  un mset nomas, activan triggers desde triggers lo que puede ser un quilombo. La llamada a activar triggers tiene que estar adentro de la generacion, por lo que voy a necesitar una condicion especial al final que llame a eso,  o mas facil, tener un bit y setearlo desde el mset* y meter un if. Testear el costo de un if en el flujo principal, no creo que sea importante

creo que esto puede ser reemplazado por codigo no ligado a pieza entre turnos? despues de cada accion corre este codigo, que puede activar triggers, y despues se corren las reacciones. Lo malo de esto es que no se aprovecha del mecanismo de triggers y va a correr todo el codigo todos los turnos, pero tiene mas usos y es mas facil de entender.

----



small vector optimization para normales y eso? 

---

arreglar todo el tema de esp que quedo todo roto

---

se podría agregar un mecanismo a triggerbox para limpiarlo si se acumulan demasiados triggers, asumiendo que si hay muchos muchos son falsos. 
No sé que tan util es en un caso real, pero en casos como el test de la dama con muchos turnos ayudaria

---

lector:
detectar esps
notacion infija

se podría cambiar goto por mset x l0 y cosas asi? al principio no me convencia porque son 2 acciones, pero normalmente con goto terminan siendo 2 tambien porque necesito setear una variable temporal y eso. Cuando agregue variables temporales no va a importar igual

Errores del scanner podrian imprimir los tokens hasta el punto del error. ERrores del parser podrian imprimir linea entera

nombrar piezas por string, el tokenizador lo pasa a id. Va a haber una palabra other para indicar otro bando

el codigo general tiene que prohibir mov

notacion infija

---

memorias de tile + global suficientemente grandes superan el tamaño de bucket y escriben afuera. Por ahora no hago nada porque creo que tenía pensado cambiar el bucket por un vector, no sé

----
Estaria bueno tener una forma de ver si la escritura de una tile fue hecha por una pieza que no se movió desde que la hizo. El mecanismo para esto ya esta, porque se usa para ver si el trigger debería activarse cuando se pisa, pero no esta expuesto al lenguaje. 
Sería util para tener un mecanismo para marcar casilleros sin necesidad de tener que limpiarlos despues, que es para lo que se usa ahora, nomas que el lenguaje no lo puede aprovechar.

Podría haber un sistema aparte con funciones mark y checkMark, pero reutilizar lo que se tiene en tiles es mejor porque practicamente no hay que hacer codigo nuevo, se usan las estructuras existentes y desde el lenguaje es mas flexible, porque se pueden usar distintos slots de memoria de tile y el contenido de las memorias.
Lo unico que se agregaria es una condicion marked que toma un numero, que indica que slot de la tile sobre la que se esta parado mirar. Si hay algun trigger, y este trigger no varió en step con la pieza que lo puso, devuelve verdadero.


No es un operador que indica directamente si un casillero esta siendo amenazado igual, porque piezas que tengan mas de un paso, como un torre, podrian ser cortadas y mantendrían marcados casilleros donde ya no estan haciendo nada. Esto no es un problema con triggers, porque serían triggers falseados y listo, pero usar esto para logica de lenguaje podría ser confuso. Para manejar algo asi sería necesario que las piezas que se cortan sigan recorriendo, y escriban en ese slot algo que indique que la marca no es valida, que despues se tiene que contrastar ademas de mirar si esta marcado. El tema esta en que cuando uno esta generando no sabe si es una generacion inicial o una regeneracion, y este codigo solo tiene sentido en una regeneracion. Cuando se choca con una pieza no se sabe si es porque esta cortó el movimiento o si nomas se choco con una pieza, y la solucion simple es seguir hasta llegar al borde del tablero siempre.
Que tenga este problema me hace dudar de si vale la pena agregarlo. 
Otra opcion es verificar si un trigger es falso o no con un recorrido como el que hace reaccionar, pero es un quilombo tambien (o no, puede que ande bien y listo)

La funcion mas util que tiene es para piezas como el rey, que solo se pueden mover a espacios no marcados. Igual soluciona solo parte del problema, y el rey se puede implementar de otra forma.

----

para terminar la dama falta prohibir los movimientos de las demas piezas cuando se esta obligado a comer, lo que requiere un mecanismo que usa el rey tambien, que implica cambiar un flag, una accion, durante un recalculo de condicion. Viene de la mano la optimizacion esa para evitar recalculos. 
Este caso tiene algo mas de complejidad porque puede darse que 2 piezas reaccionen al mismo tiempo, y las 2 efectuen el bloqueo. En este caso, implementado a lo perro, el orden de evaluacion tendria un efecto. No deberia pasar eso. Esto significa que hay que diferir las acciones en condiciones a despues de la evaluacion de todas las reacciones. Creo que esto no genera ningun problema.

Si decido hacer que se puedan correr acciones aleatorias, no solo msets, podría tener otra forma de implementar el corte al paso, haciendo que el peon se suicide si detecta que alguien se movio atras de él. Es medio malo igual porque hay que manejar el caso especial de que lo coma un peon

----

algun chequeo de bordes opcional cuando se esta trabajando con memoria en el lenguaje? no estoy seguro de que tan util sería, un assert vs un crash posible

----

Creo, creo, que el rey se puede implementar sin hacer cosas raras haciendo que:
El rey haga el movimiento inverso a cada pieza para mirar si alguien lo esta amenazando.
Atraviesa piezas aliadas para mirar mas alla, si hay una pieza enemiga marca la aliada para que esta no se pueda mover
Cuando una pieza enemiga se mueve y lo amenaza va a tener que hacer todo el quilombo de acciones en condiciones igual gg

El rey actualiza en tiempo de condicion una memoria global, y tambien pinta los tiles que se podrían pisar para bloquear el jaque.
En cada pieza, envolviendo c hay un isol que mira esta global y el tile. Los recalculos estan contenidos en estos isoles, por lo que solo se recalcula eso. Aunque hay una explosion de triggers, pero bueno, es eso nomas. 
Para esto no es necesario esa optimizacion de no recalcular cadenas validas que no recibieron triggers y estan mas alla de zonas que si recibieron cambios


recordar que pienso agregar funciones que miren el futuro mas adelante, puede que la version final no sea tan enquilombada

la dama podria usar memset* para prohibirse a si misma


Una opcion mucho mas simple sería exponer al lenguaje los clickers, y tener un comando que los invalide y listo. El rey, al ser amenazado, va a invalidar todos los clickers excepto los que lo cubran, evaluandolos segun la posicion. No sé exactamente como sería la sintaxis para recorrer la lista de clickers, algo como forEachClick [] end donde se puede acceder a algunas variables especiales como la posicion del puntero y la pieza dueña. Es la solucion mas directa, simple y eficiente.
Supongo que no pense en esto antes por limitarme a la idea de que cada pieza es dueña de los movimientos que genera, y eso llevo a la otra implementacion que bajo esas restricciones cumplia pero terminaba siendo mucho mas compleja y bizarra, y de todas formas rompia la regla de no tener efecto en las condiciones.
-
un problema aparte es prohibir movimientos que descubran al rey y lo dejen amenazado. La verificacion de every podría buscar estas piezas y marcarlas para que no generen desde el principio. Es una verificacion mas compleja pero creo que es la unica forma razonable.

Agregar un control tipo every, que verifique que el rey no sea amenazado despues de mover una pieza, no funcionaria porque la cancelacion del movimiento se hace al finalizar su generacion, y every corre despues de que pase una accion. Esto parte del tema de la separacion de las condiciones y acciones, si se hiciera todo junto con la idea de reversibilidad se podría hacer la verificacion mas directamente. 


----

Estaria bueno que debug te escriba todo el movimiento y te marque en que condicion estas. Tambien podría mostrar las acciones acumuladas y tener un efecto cuando se hace un clicker. Es todo un proyecto pero lo vale.

Un tema es manejar el tamaño para asegurarse que entre en pantalla, y hasta por ahi hacerlo scrolleable si no entra. Lo mismo con memorias demasiado grandes. Creo que lo debería hacer porque esto es algo que va a usar el usuario tambien, tampoco que sea tan complicado pero bueno.

----

negar condiciones? podria andar pero nunca lo necesite por ahora

----

usar una notacion distinta para acciones y condiciones de memoria, por ejemplo
mset g0 5 mcmp g0 5 es falso la primera vez, y puede ser confuso

Supongo que haria esto junto con lo de notacion infija y variables temporales

Macros con parametros no son absolutamente necesarios, pero serian utiles. 
-
Si agrego esto se podría agregar un token \;, para poder hacer un macro que se expanda en varios movimientos. Con esto se podrían hacer piezas parametrizables.
-
estaria bueno que estos macros puedan definir macros locales, seria comodo para definir piezas. Por ahi es medio raro de implementar igual porque la etapa de definicion es anterior a la expansion, ver
Va igual se pueden definir esos macros locales como globales anteriores al macro para la pieza y listo, lo unico malo es que se contamina el namespace global pero no importa mucho

Tambien estaria bueno poder expandir macros en secciones de movimientos, por ejemplo en el interior de un desopt. Igual no estoy muy seguro de como seria eso

>X = a 
>Y = b X b
>X = c
Y se expande a ???. Por ahora se expande a "b a b", porque no reacciona al cambio de x, ya esta fijado el token anterior. El shadowin hace efecto cuando se transforma texto en tokens. Podría cambiar las cosas para que no pase eso, haciendo que Y sea dependiente de X o algo asi, pero es algo bastante niche y no lo vale. Ademas si agrego parametros estos cubren este caso de uso.

----

comando? que repite turno, si hay solo un clicker se selecciona automaticamente.

----

?? comando que no actualice el step de una pieza, util para piezas que se bloquean pero sus triggers viejos les siguen interesando y no vuelven a generar. (Creo que estoy hablando de algo como la idea de lock vieja)

----

No sé hasta que punto valdría la pena agregar funciones de alto nivel como tener un comando no-repeat que automaticamente prohiba moverse a casilleros que se marquen con otro comando, o un comando que marque casilleros y desmarque comforme las piezas se muevan y corten entre si, o implementar el jaque automaticamente. Estas cosas son caras para el interpretador pero serían baratas para la version compilada. No me convencen mucho porque nomas sirven para cosas especificas, y estas cosas se pueden implementar en el lenguaje de todas formas. Tampoco me gusta porque agrega complejidad al lenguaje, cosas que hay que mantener y el usuario tiene que aprender. Siempre tuve una mentalidad de bajo nivel, y creo que me voy a mantener asi.

-----

Seria interesante agregar un modo inmediato al ajederes, donde se hacen todos los movimientos cada vez, no hay recalculos. Debería agregar algo de metaprogramacion para no duplicar codigo. Es un proyecto interesante, y serviria para tener una idea de que tanto beneficio me da el mecanismo de recalcular. Osea estaria bueno para tener una idea de que beneficios me dio hacerlo de la forma que lo hice.
Igual es para probar yo nomas, no va a quedar como algo opcional. Mantener el codigo ese seria un asco, el lenguaje se comporta de forma distinta dependiendo del modo lo que es raro (condiciones y acciones y cargas se evaluan juntas), y es una opcion compleja y confusa para el usuario. Y tiene peor respuesta, porque los movimientos se calculan cuando se toca la pieza.

Otra cosa que por ahí se puede probar es que cuando se active un trigger se recalcule el movimiento entero. Esto simplifica mucho las cosas porque saca la necesidad de reaccionar. Dudo mucho que incremente la velocidad porque reaccionar sobre un tramo de codigo es mas rapido que regenerarlo, lo que me hace dudar es que la mayoria de los movimientos complejos terminan recalculando una parte importante de si mismos, y el no tener que andar manejando multiples triggers y boludeces puede tener un impacto. No creo pero se podría probar si no tengo nada mejor que hacer.

----

la version interpretada se va a usar en el editor, y va a tener todas las boludeces de debug ahi. El compilado para el juego juego.

----

los vectores temporales podrian compartir una memoria. Es algo re opcional igual, si sale sale

----

no es necesario inicializar la free list creo, pero puede que eso cree mas chequeos mirar

----

limpiar triggers falsos en tiempo muerto? osea cuando esta esperando al jugador

sacar archivos de boludeces

----

para los mecanismos de mirar al futuro bastaria con tener una memoria que los turnos futuros pueden escribir, que se lee desde el presente? creo que si. Igual no tengo claro que pasa una vez que se reacciona a la informacion del futuro, porque lo invalidaria. No sé si tiene sentido esto


####


alguna forma de seleccionar memoria para no copiar todo siempre. Hacerlo por campo me parece que seria mucho overhead, puedo partir por sectores inteligentes (por movimiento o algo asi) y tener memoria en bloques para memorias. O usar bloques para todo. Sé que bloque use porque para acceder hago que pase por un coso el puntero, lo que es overhead pero bueno. Se puede ver si lo vale. Esto se aplicaria solo a accesos a la memoria del juego o a todo los accesos

El sistema de evaluacion de la IA esta en el lenguaje, con comandos que dan puntos. Lo bueno de esto es que puedo combinarlo con codigo que corre todos los turnos para tener una evaluacion totalmente configurable. Supongo que va a haber algunas cosas hechas como contar cantidad de piezas para ser mas rapido, pero si se quiere hacer algo aparte se puede. Igual creo que el evaluador principal es la cantidad de capt/movs que tiene cada jugador, y eso deberia venir hecho

Por ejemplo se le podría dar un valor a amenazar espacios cercanos al rey, para intentar impulsar un jaque.

antes tenia planteada la idea de tener una matriz de cambio y manejar solo las diferencias con el tablero en lugar de tener el una copia por thread, no sé si vale la pena hacer eso pero es una idea.

visualizaciones de la ia, barra de progreso

algun control de quien tiene el turno para segundo orden? por ahi se pueden hacer cosas con esa

las condiciones que ven el futuro pueden hacer paradojas, lo que es raro. Por ejemplo un movimiento que haga algo en funcion a un escenario futuro, al ver eso y hacer la accion va a crear un nuevo futuro. Creo que lo dejo ahi y listo, sino seria un bucle infinito. Pero es algo que pensar. 

en la version compilada podria haber un flag que haga que no haya crashes por exceder deslices y eso

probabilistica se puede meter usando una condicion nomas. Seria facil de entender pero la funcionalidad con la ia es media rara,  lo ve como una condicion comun y se manda por lo que salga. 

threads en el levante de piezas

Se podría agregar internet si me interesa meterme en eso. Él jugador cliente se conecta por ip al server que le pasa el tablero y las definiciones de las piezas, se construye el juego en los dos lados y la mayoría de los cálculos se hacen de los dos lados también. Necesitaría una forma de poder indicar que movimiento se eligió, mandar la pos de la pieza y click no es suficiente por el solapamiento, pero algo como esto sería lo más cómodo. Por ahí el índice de la lista de movimientos total la tengo que generar de los dos lados y debería ser igual.

fuente de texto libre

estetica:
poder cambiar tamaño pantalla 
poder hacer zoom en tableros grandes
comandos que cambien sprites de piezas? y de fondo

editor:
para poner piezas se toca y se seleccionan de un menu
para piezas nuevas hay un menu de sprites
resistir crashes
bloqueadores de camara


esta la idea de hacer un juego meta, lo que necesitaria comandos meta. Medio choto igual no sé si me convence. Si es solo cambiar el estado de una pieza se puede hacer teniendo los caminos posibles desde un principio. Si es algo mas loco no creo que sea divertido, muy caotico

-----

Seria interesante generar una normal para cada combinacion posible de sus bools, porque son cte. Eso ahorraria unos ifs, no sé si tendria un gran impacto pero es algo que se podría hacer. Lo mismo con los getters y eso. Los templates no son suficientemente buenos porque tengo que hacer cada combinacion posible, y me gustaria hacerlo de forma automatica. Tambien me gustaria generar el codigo que llama a esto, que tambien seria un asco hacer a mano. No estoy muy seguro de que sea muy util y seguramente sigue siendo peor que hacer el compilador, que basicamente hace esto pero mejor y con todo el codigo, pero es un proyecto de metaprogramacion interesante. 

-----


clickers especiales para movimientos de varios pasos (solo el ultimo es real). El juego por atras calcula todos los caminos posibles como siempre, nomas esta como algo para la interfaz del jugador humano. 

-----

WhenNoMoves
Ahora cuando un jugador se queda sin movimientos y es su turno el juego queda en softlock. Se podría dejar asi y listo. Una solucion desde adentro del lenguaje es agregar un boton de rendicion. 
Se puede agregar un sistema que detecte esto. No estoy seguro de si lo valga, agrega chequeos cada vez que se acciona. Para adaptarse a cada juego posible tiene que chequear si los dos jugadores tienen movimientos posibles despues de cada accionar.
Se sabe que un jugador tiene movimientos si tiene un holder que tenga un movimiento que tenga su primer movholder con valorCadena verdadero.
En primera instancia se podría mirar el holder que genera despues de moverse y los que reaccionan para ver si estos hacen algo. Si eso falla se va a tener que recorrer el tablero buscando algun holder que cumpla la condicion. Si no hay ninguno se llega a la conclusion de que no hay movimientos.
Cuando pasa esto, se corre el codigo WhenNoMoves asociado a ese jugador
-
Cuando los dos jugadores se bloquean al mismo tiempo andaria medio raro, pero supongo que se puede salvar  

------

alguna forma de agregar sprites solo esteticos


--------

Se podría agregar un operador rand que es una especie de opt, pero solo
corre una rama elegida aleatoriamente
En el lenguaje se tendría que escribir un porcentaje en cada rama, y todas
las ramas tienen que sumar 100
Dentro de todo es simple y da bastante juego.
En la IA se puede implementar haciendo una cuenta que tome el valor y riesgo de 
hacer cada movimiento, pesados por su probabilidad
Un problema de generalizacion es este: Hay dos ramas, una verdadera y una
falsa. Debería descartarse la falsa y solo tener en cuenta la verdadera, o
elegir aleatoriamente entre las dos y si cae la falsa no hacer nada?
por ahi manejar los 2 casos, aunque condiciones despues de rolls es medio raro.

-----------

!mirar el tema del copyrigth con las fuentes


>>
metaprogramacion
marcar regiones, dentro de estas regiones poder tener variables. Despues de la region hay codigo en c que se encarga de generar un archivo donde se va a pegar el codigo y compilar, con todo eso ya cubierto. El codigo solo hace el fprintf, por ahi con una notacion especial para abstraer el orden de parametros, y ahi se pueden hacer cosas como pegar el codigo n veces con algo cambiado o que sé yo

Algo interesante seria tener un operador que transforme un grupo de acciones y condiciones en una accion. Con esto se estaria delegando todo un procesamiento a la ejecucion, lo que podría optimizar algunas cosas. Creo que tiene sentido esto y no estoy rompiendo nada.
Si el operador envuelve todo el movimiento seria como estar en el modo inmediato. Y ahi esta el tema, que la IA no sabe que hacen estas cosas y no puede calcular el cambio cuando mueve una pieza, lo que lo fuerza a recalcular todas estas acciones para saber si quiera si cambiaron.

agregar funciones, como una alternativa a macros, no tiene mucho sentido. Es muy complejo y no aporta mucho. No ahorraria el codigo repetido, que es la unica funcion que tiene y lo separaria de un macro, porque se necesita guardar la evaluacion para poder saltar a esta y eso. Por lo que las funciones solo servirian para cosas que no se guardan, que son practicamente nada.
Por ahi si hay mucho codigo, en una misma pieza o entre piezas, y este codigo usa la misma memoria en la misma posicion y es todo igual se podria hacer una abstaccion que ahorre calcularlo cada vez, pero saber cuando calcular y cuando no es practicamente imposible y solo serviria en casos muy raros. Los triggers a que apuntarian? 

operaciones de memoria usando un stack. El codigo supuestamente es mas simple pero es mas dificil de entender. 
madd l0 l1 = push l0 push l1 add load l1 
En vez de variables globales tendria el stack.
No me gusta porque es mas complicado, es incomodo, y usa mas memoria, porque se tiene que guardar el stack y el puntero a este, mientras que con memoria nomas guardo la memoria (y los punteros estarian en el codigo). Ademas con el stack hay que pasarle el maximo tamaño que va a usar, lo que no es tan obvio.
Algo a favor es que no necesita polimorfismo, es todo push y load

No es buena idea juntar condiciones y acciones. El lenguaje se hace mas simple pero es mas lento. La idea era que con segundo orden tengo que hacer las acciones de todas formas, asi que las puedo hacer tambien intercaladas con las condiciones. Pero esto no aplica a la ultima iteracion, donde las acciones se harian al pedo. Y casos donde no se use segundo orden. Y mas importante, fallos de condiciones en un mismo movimiento que ahora van a forzar a hacer una regresion de las acciones, no sabría como implementar esto porque no tengo un snapshot antes de cada condicion, como si hago entre turnos. Y restaurar de un trigger, que es algo que sigue pasando, requeriria tambien una regresion rara.
Es mucho quilombo y hay cosas que no sé si tienen sentido. 
Forzar que el movimiento depende solo del estado actual del tablero no es una idea tan compleja




la unica mecanica que no tengo totalmente clara es la de tener mas de un movimiento en un turno. Se puede hackear con flags haciendo que el otro tenga un turno sin movimientos validos, pero podría haber algo mejor. Creo que esto amerita tener codigo especial para manejarlo, y en principio no veo ningun problema en hacer eso. Tambien permite mecanicas interesantes como botones para hacer votaciones y cosas asi, que son acciones independientes que no deberían consumir un turno (aunque se evaluan al mismo tiempo, no son asincronicas. Si se quiere algo en muchos pasos con interaccion del otro jugador si se usarian flags)

La partida termina en empate si se repiten los mismos movimientos 3 veces o no se come ninguna
pieza ni se mueve un peon en los ultimos 30 turnos

Cuando la maquina esta perdiendo (le quede un porcentaje de sus piezas iniciales y diferencia con la cantidad del jugador) 
las tiles del fondo empiezan a cambiar aleatoriamente, con una chance dependiente del porcentaje


un tablero con una doble fila de amigo-huerfanos seria interesante

un ajedrez como el comun, pero en cada turno se tienen que mover dos piezas distintas
-variante donde se tienen que mover piezas de distinta clase (en el primer turno se movería un peon y un caballo)
-variante donde se tienen que mover piezas de la misma clase

ajedrez hecho unicamente de piezas bizarras, con propiedades raras y movimientos con efectos secundarios

ajedrez donde varias piezas puedan replicarse, mecanicas alrededor de eso

un tablero de islas, con plataformas que se mueven
-las plataformas serian espacio vacio entre paredes, se manejaria con algun every que va moviendo las paredes
se podría agregar plataformas que se mueven, como barcos. Estos tendrían una pieza tecnica que haga de control, que permita mover el barco y las piezas que esten arriba. Si el espacio de control esta ocupado este se mueve a un espacio no ocupado o se corre el codigo de control desde la pieza que lo ocupo


PIEZAS:
https://en.wikipedia.org/wiki/Fairy_chess_piece
https://en.wikipedia.org/wiki/Chess_with_different_armies
https://en.wikipedia.org/wiki/Baroque_chess
https://en.wikipedia.org/wiki/Wa_shogi
https://en.wikipedia.org/wiki/Stratomic
pieza que genere estructuras
pieza que cambie su posicion con cualquier otra dentro de un rango de 3
pieza que pueda generar paredes
una pieza vivorita multiblock
pieza camuflada, en grupos, tiene como movimiento especial ser reemplazada por otra pieza, y hacer que el resto de su clase
se vuelvan normales (ej grupo de peones donde uno se puede volver reina, los otros quedan normales)
Pieza que respawnee
pieza multiblock. Ni idea de como capturaria o sería capturada, pero no estaría mal.
pieza ariete, que pueda contener otra pieza 
pieza que tenga un movimiento que permita cambiar su posicion con cualquier otra, y pueda hacer esto varias veces
en un mismo turno
pieza absorbente, que obtiene todos los bloques de movimiento, accion y propiedades de quien absorva. Necesita absorver
a una pieza aliada para comenzar a actuar, su unico movimiento inicial es absorver ortogonalmente. Puede que este un 
poco rota. Es una cuestion de tener una super pieza vs tener muchas piezas.
pieza que levante paredes a su alrededor al finalizar cada turno y las baje antes de calcular sus movimientos
pieza que deje un trail de piezas tecnicas permanente
Aislador: Cuando activa su habilidad especial inmoviliza todo lo que no este en un radio de 5x5 a su alrededor, hasta que sea capturado o pase cierta cantidad de turnos Al moverse mueve el campo alrededor. Lo malo de esta pieza es que es muy facil crear situaciones de tablas, aunque eso podría tomarse como un aporte porque no te permite hacer estrategias muy forras, ya que si le matas a todas sus piezas no congeladas se termina el juego, y el oponente siempre tiene la opcion de mover sus piezas fuera para congelarlas, lo que lleva a situaciones bizarras. Esta bueno.
torre que hace la cruz en su pos actual y una en la que estuvo antes y marcó
pieza que se duplica todas las veces que quiera, pero si se la comen se comen todas
pieza que no se puede mover si el enemigo esta haciendo una formacion especifica con sus piezas
pieza invisible que mata piezas que se muevan o atraviecen su casillero. La complejidad esta en que tiene que mockear los clickers de las otras piezas para que no parezca sospechoso
serpiente con camino hamiltoniano
todas las piezas se mueven hasta chocar con algo
piezas que solo den estados alterados a otras piezas
ajedrez 69 solomon
Una pieza que se mueva y pueda invocar orbes ortogonalmente, los orbes son piezas sin movimiento propio que se mueven en la misma direccion un casillero por turno. Desaparecen al salir del tablero o capturar una pieza de cualquier bando
Torre 2x2, solo frena si pisa dos piezas a la vez. Supongo que nomas una esquina es clickeable
Pieza controlable por ambos jugadores, cambia de bando cada turno
pieza solo capturable por una clase de piezas
forma de convertir piezas en otras, si se convierte al rey se tiene una version 'real' de esa pieza
pieza con hitpoints
Pieza que promociona despues de capturar 3 veces
Pieza cuyo rango dependa de la cantidad de piezas de cierto tipo en el tablero
Pieza con pieza hermana, entre las dos forman un area. Cualquiera puede saltar a cualquier punto de esta area. Si se las lleva a las esquinas del tablero se tendría un universal leaper
el bufon, arranca fuera del tablero y puede saltar a cualquier casillero vacio. De ahi en adelante copia los movimientos de la ultima pieza enemiga que se haya movido.
portales
pieza que pueda moverse una vez sin gastar el turno
el cocodrilo para un cuerpo de agua aleatorio es un problema complicado? Habria que implementar un space fill desde el lenguaje, que tenga en cuenta las costas. No se que tan feo seria, ver. Igual se puede harcodear para cada tablero especifico

En retrospectiva podría haber terminado el proyecto mucho antes, y de forma mas eficiente, harcodeando todas las piezas. Ese nunca fue el fin del proyecto, pero bueno, da para pensar eso. Hacer el lenguaje de alto nivel tiene sus ventajas, es mucho mas amigable y permite iterar cosas simples rapido. Pero tiene sus desventajas, fue una inversion grande para mi hacerlo y limita la flexibilidad de lo que se puede llegar a crear. Si hubiera hecho algo tipo un framework de c menos usuarios podrían hacer cosas, por necesitar aprender muchas cosas especificas y molestas, pero las cosas que crearian esos usuarios serían considerablemente mas custom e interesantes. El teorema del colchon de agua. 
Puede que igual un acercamiento asi termine mas o menos en lo mismo que a lo que llegue. El mecanismo de reaccion es la parte mas pesada y mas automatizada por el lenguaje. Tener que hacer un sistema como ese para cada pieza sin tener errores de consistencia en cada punto de restauracion seria bastante incomodo. Y usando abstracciones que lo manejen terminaria con lo mismo que el lenguaje. Puede que se maneje un poco mejor igual, pero al costo de mucho trabajo, bloat de codigo y riesgo de errores. La falta de estandarizacion haria que piezas complejas tengan mala interoperabilidad










La alternativa que sería mas rapida y mas flexible sería hacer que el lenguaje de piezas compile a codigo en c++
Hace el arranque mas complejo:
Habria un programa inicial que te da a elegir el tablero. Una vez elegido, el programa genera el codigo de las piezas, lo compila junto con el resto del juego y lo arranca. (Puede que parte del juego este compilada y espere que se linkee, no sé)
Tambien esta el tema de que debería andar con varios compiladores, lo unico que debería cambiar es la llamada nomas igual

La gran ventaja de generar codigo es que ahora toda la estructura de movHolders y movimientos es inline.
Tambien se pueden agregar optimizaciones especificas como no meter control de memoria en movimientos que no usan memoria, no necesitar pasar argumentos de mas a movs que no los necesiten, separar esp de otras conds, no recalcular posAct si no se mueve, agregar un solo trigger por pos, etc
Puede tener una desventaja menor de que al generar codigo hay mas bloat y eso afecte a la cache, pero no creo. 

Puede que la separacion entre operador y holder ya no tenga sentido en este modelo. Podría hacerse que el holder contenga las estructuras necesarias para funcionar, que pueden variar (a demas de los datos de holder, una normal sola solo tendría el array de acciones, pero un desliz necesita un vector de normales y algunos datos de control) y operador sea solo la funcion generar

ej
w vacio mov
->
(los movimientos probablemente esten inline)
void mov.generar(data* dat){
    v posAct;
    posAct=data->pos+v(0,1);
    if(!esp(posAct)){
        valido=false;
        return;
    }
    agregarTrigger(posAct);
    if(!vacio(posAct)){
        valido=false;
        return;
    }
    posAct=data->pos+v(0,1);
    data->accs[0].pos=posAct;
}

agregarTrigger sería algo como 
tablero->tile(posAct)->triggers.push_back(Trigger(this,1));

el 1 es un numero de control para el mecanismo de reaccion. 
No tengo claro si usar una la funcion de generar para reaccion y generar, o tenerlas como cosas separadas.
-
el mecanismo de reaccion es complicado. Si fuera todo plano sería un switch con gotos al principio de la funcion, pero con desliz eso no funciona directamente.
Una solucion que creo que funcionaria para todos los casos es ir asignando numeros a cada eslabon del desliz cuando se genera. En el switch hay un for por cada desliz que mira el numero que se pasó es de ese desliz. Si lo es se salta a este acomodando su iterador. Esto se puede hacer andar con anidacion. Los iteradores entonces quedan ligados a un valor generado en runtime. La n-upla que guarda esto se genera cuando se compila. 
No sé si es la solucion mas simple
Tambien tiene que guardar un offset para pos 






desliz w vacio mov end

void mov.generar(data* dat){
    v posAct;
    posAct=data->pos;
    i=0;
    while(true){
        posAct+=(0,1);
        if(!esp(posAct)){
            cap=i;
            return;
        }
        agregarTrigger(posAct);
        if(!vacio(posAct)){
            cap=i;
            return;
        }
        posAct=data->pos+v(0,1);
        data->norm[i].accs[0].pos=posAct;
    }
}




Algo bizarro que se podría agregar facil es la habilidad de poder insertar codigo en c++ directamente adentro del lenguaje de piezas, escribir algo como
desliz w mover <@for(int i=0;i<50;i++) cout<<"dasda";@> end
(el codigo se marcaría como condicion o accion con alguna notacion. El codigo que se genera esta dentro de una funcion bool o void, respectivamente)
No sé si hay algun contexto en el que sea util, pero estaría bueno. 
Se podría llamar a comandos comunes usando los nombres de las funciones, como 
mov(), etc. Como no es el lenguaje de piezas el que esta llamando cosas como esp no se van a poner automaticamente, los movimientos del puntero no se van procesar junto con las del lenguaje, etc. Pero si uno es conciente de estas limitaciones no habría problema.


La alternativa que sería mas rapida y mas flexible sería hacer que el lenguaje de piezas compile a codigo en c++
Hace el arranque mas complejo:
Habria un programa inicial que te da a elegir el tablero. Una vez elegido, el programa genera el codigo de las piezas, lo compila junto con el resto del juego y lo arranca. (Puede que parte del juego este compilada y espere que se linkee, no sé)
Tambien esta el tema de que debería andar con varios compiladores, lo unico que debería cambiar es la llamada nomas igual

La gran ventaja de generar codigo es que ahora toda la estructura de movHolders y movimientos es inline.
Tambien se pueden agregar optimizaciones especificas como no meter control de memoria en movimientos que no usan memoria, no necesitar pasar argumentos de mas a movs que no los necesiten, separar esp de otras conds, no recalcular posAct si no se mueve, agregar un solo trigger por pos, etc
Puede tener una desventaja menor de que al generar codigo hay mas bloat y eso afecte a la cache, pero no creo. 

Puede que la separacion entre operador y holder ya no tenga sentido en este modelo. Podría hacerse que el holder contenga las estructuras necesarias para funcionar, que pueden variar (a demas de los datos de holder, una normal sola solo tendría el array de acciones, pero un desliz necesita un vector de normales y algunos datos de control) y operador sea solo la funcion generar

ej
w vacio mov
->
(los movimientos probablemente esten inline)
void mov.generar(data* dat){
    v posAct;
    posAct=data->pos+v(0,1);
    if(!esp(posAct)){
        valido=false;
        return;
    }
    agregarTrigger(posAct);
    if(!vacio(posAct)){
        valido=false;
        return;
    }
    posAct=data->pos+v(0,1);
    data->accs[0].pos=posAct;
}

agregarTrigger sería algo como 
tablero->tile(posAct)->triggers.push_back(Trigger(this,1));

el 1 es un numero de control para el mecanismo de reaccion. 
No tengo claro si usar una la funcion de generar para reaccion y generar, o tenerlas como cosas separadas.
-
el mecanismo de reaccion es complicado. Si fuera todo plano sería un switch con gotos al principio de la funcion, pero con desliz eso no funciona directamente.
Una solucion que creo que funcionaria para todos los casos es ir asignando numeros a cada eslabon del desliz cuando se genera. En el switch hay un for por cada desliz que mira el numero que se pasó es de ese desliz. Si lo es se salta a este acomodando su iterador. Esto se puede hacer andar con anidacion. Los iteradores entonces quedan ligados a un valor generado en runtime. La n-upla que guarda esto se genera cuando se compila. 
No sé si es la solucion mas simple
Tambien tiene que guardar un offset para pos 






desliz w vacio mov end

void mov.generar(data* dat){
    v posAct;
    posAct=data->pos;
    i=0;
    while(true){
        posAct+=(0,1);
        if(!esp(posAct)){
            cap=i;
            return;
        }
        agregarTrigger(posAct);
        if(!vacio(posAct)){
            cap=i;
            return;
        }
        posAct=data->pos+v(0,1);
        data->norm[i].accs[0].pos=posAct;
    }
}




Algo bizarro que se podría agregar facil es la habilidad de poder insertar codigo en c++ directamente adentro del lenguaje de piezas, escribir algo como
desliz w mover <@for(int i=0;i<50;i++) cout<<"dasda";@> end
(el codigo se marcaría como condicion o accion con alguna notacion. El codigo que se genera esta dentro de una funcion bool o void, respectivamente)
No sé si hay algun contexto en el que sea util, pero estaría bueno. 
Se podría llamar a comandos comunes usando los nombres de las funciones, como 
mov(), etc. Como no es el lenguaje de piezas el que esta llamando cosas como esp no se van a poner automaticamente, los movimientos del puntero no se van procesar junto con las del lenguaje, etc. Pero si uno es conciente de estas limitaciones no habría problema.


